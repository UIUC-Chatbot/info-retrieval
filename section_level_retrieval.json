[
    [
        {
            "score": 0.2520362436771393,
            "start": 277,
            "end": 397,
            "answer": "development of an abstract model through the implementation of functions for the next-state variables and output signals"
        },
        {
            "score": 0.24124842882156372,
            "start": 268,
            "end": 397,
            "answer": "from the development of an abstract model through the implementation of functions for the next-state variables and output signals"
        },
        {
            "score": 0.17180876433849335,
            "start": 273,
            "end": 397,
            "answer": "the development of an abstract model through the implementation of functions for the next-state variables and output signals"
        },
        {
            "score": 0.05959254130721092,
            "start": 322,
            "end": 397,
            "answer": "implementation of functions for the next-state variables and output signals"
        },
        {
            "score": 0.02009108103811741,
            "start": 292,
            "end": 397,
            "answer": "an abstract model through the implementation of functions for the next-state variables and output signals"
        }
    ],
    [
        {
            "score": 0.04278751090168953,
            "start": 960,
            "end": 1070,
            "answer": "input and/or output specifications may need to match other digital systems to which we plan to connect our FSM"
        },
        {
            "score": 0.036266956478357315,
            "start": 953,
            "end": 1070,
            "answer": "Often, input and/or output specifications may need to match other digital systems to which we plan to connect our FSM"
        },
        {
            "score": 0.02173476293683052,
            "start": 960,
            "end": 1070,
            "answer": "input and/or output specifications may need to match other digital systems to which we plan to connect our FSM"
        },
        {
            "score": 0.018679970875382423,
            "start": 953,
            "end": 1070,
            "answer": "Often, input and/or output specifications may need to match other digital systems to which we plan to connect our FSM"
        },
        {
            "score": 0.017915770411491394,
            "start": 960,
            "end": 1034,
            "answer": "input and/or output specifications may need to match other digital systems"
        }
    ],
    [
        {
            "score": 0.36862054467201233,
            "start": 150,
            "end": 255,
            "answer": "a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit"
        },
        {
            "score": 0.2591741383075714,
            "start": 150,
            "end": 199,
            "answer": "a cycle over all bit patterns of a certain length"
        },
        {
            "score": 0.10885646939277649,
            "start": 150,
            "end": 179,
            "answer": "a cycle over all bit patterns"
        },
        {
            "score": 0.07192181795835495,
            "start": 152,
            "end": 255,
            "answer": "cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit"
        },
        {
            "score": 0.05056764930486679,
            "start": 152,
            "end": 199,
            "answer": "cycle over all bit patterns of a certain length"
        }
    ],
    [
        {
            "score": 0.061430905014276505,
            "start": 95,
            "end": 146,
            "answer": "use a Gray code as the basis for the state sequence"
        },
        {
            "score": 0.040881067514419556,
            "start": 43,
            "end": 146,
            "answer": "Now we'll add a third bit to our counter, but again use a Gray code as the basis for the state sequence"
        },
        {
            "score": 0.033366404473781586,
            "start": 53,
            "end": 146,
            "answer": "add a third bit to our counter, but again use a Gray code as the basis for the state sequence"
        },
        {
            "score": 0.027948183938860893,
            "start": 47,
            "end": 146,
            "answer": "we'll add a third bit to our counter, but again use a Gray code as the basis for the state sequence"
        },
        {
            "score": 0.012767351232469082,
            "start": 118,
            "end": 146,
            "answer": "basis for the state sequence"
        }
    ],
    [
        {
            "score": 0.18115286529064178,
            "start": 519,
            "end": 533,
            "answer": "At least three"
        },
        {
            "score": 0.049979306757450104,
            "start": 519,
            "end": 549,
            "answer": "At least three, since _2 (5)=3"
        },
        {
            "score": 0.027628479525446892,
            "start": 528,
            "end": 533,
            "answer": "three"
        },
        {
            "score": 0.021688004955649376,
            "start": 519,
            "end": 550,
            "answer": "At least three, since _2 (5)=3."
        },
        {
            "score": 0.01588335819542408,
            "start": 519,
            "end": 587,
            "answer": "At least three, since _2 (5)=3.  Given that we need three flip-flops"
        }
    ],
    [
        {
            "score": 0.14388760924339294,
            "start": 3379,
            "end": 3433,
            "answer": "to choose between normal operation (INIT=0) of the FSM"
        },
        {
            "score": 0.0936049073934555,
            "start": 3379,
            "end": 3473,
            "answer": "to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state"
        },
        {
            "score": 0.07681284099817276,
            "start": 3379,
            "end": 3492,
            "answer": "to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0"
        },
        {
            "score": 0.0625334158539772,
            "start": 3379,
            "end": 3413,
            "answer": "to choose between normal operation"
        },
        {
            "score": 0.054510898888111115,
            "start": 3382,
            "end": 3433,
            "answer": "choose between normal operation (INIT=0) of the FSM"
        }
    ],
    [
        {
            "score": 0.20686644315719604,
            "start": 1562,
            "end": 1590,
            "answer": "pressing the ``halt'' button"
        },
        {
            "score": 0.11548236757516861,
            "start": 1559,
            "end": 1590,
            "answer": "by pressing the ``halt'' button"
        },
        {
            "score": 0.07597295194864273,
            "start": 1575,
            "end": 1590,
            "answer": "``halt'' button"
        },
        {
            "score": 0.07528486102819443,
            "start": 1577,
            "end": 1590,
            "answer": "halt'' button"
        },
        {
            "score": 0.04697686433792114,
            "start": 1518,
            "end": 1590,
            "answer": "A user can stop the counter in any state by pressing the ``halt'' button"
        }
    ],
    [
        {
            "score": 0.6869872212409973,
            "start": 253,
            "end": 267,
            "answer": "For the output"
        },
        {
            "score": 0.08098749071359634,
            "start": 257,
            "end": 267,
            "answer": "the output"
        },
        {
            "score": 0.051888108253479004,
            "start": 261,
            "end": 267,
            "answer": "output"
        },
        {
            "score": 0.022900687530636787,
            "start": 253,
            "end": 355,
            "answer": "For the output, we use a two-bit  Gray code.  With these choices, we can redraw the transition diagram"
        },
        {
            "score": 0.0181336160749197,
            "start": 253,
            "end": 377,
            "answer": "For the output, we use a two-bit  Gray code.  With these choices, we can redraw the transition diagram  as show to the right"
        }
    ],
    [
        {
            "score": 0.3550773561000824,
            "start": 2022,
            "end": 2050,
            "answer": "Use of explicit bit patterns"
        },
        {
            "score": 0.0898481160402298,
            "start": 2029,
            "end": 2050,
            "answer": "explicit bit patterns"
        },
        {
            "score": 0.054353371262550354,
            "start": 1554,
            "end": 2050,
            "answer": "Answering these questions is part of fully specifying our design.  We can choose to leave some parts unspecified, but { any implementation of our system will imply answers}, and thus we must be careful.  We choose to ignore the ``go'' button while counting, and to have the ``halt'' button override the ``go'' button.  Thus, if HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}. And, if HG=11, the counter moves to state { HALT A}.  Use of explicit bit patterns"
        },
        {
            "score": 0.04501720517873764,
            "start": 2022,
            "end": 2065,
            "answer": "Use of explicit bit patterns for the inputs"
        },
        {
            "score": 0.01583019271492958,
            "start": 2022,
            "end": 2050,
            "answer": "Use of explicit bit patterns"
        }
    ],
    [
        {
            "score": 0.11276384443044662,
            "start": 887,
            "end": 905,
            "answer": "The right strategy"
        },
        {
            "score": 0.03901581093668938,
            "start": 2714,
            "end": 2803,
            "answer": "Having chosen a representation, we can go ahead and implement our design in the usual way"
        },
        {
            "score": 0.03888116776943207,
            "start": 887,
            "end": 1115,
            "answer": "The right strategy is thus often to start by selecting a representation  that makes sense to a human, even if it requires more bits than are strictly necessary.  The resulting implementation will be easier to design and to debug"
        },
        {
            "score": 0.03391279652714729,
            "start": 2746,
            "end": 2803,
            "answer": "we can go ahead and implement our design in the usual way"
        },
        {
            "score": 0.0314309261739254,
            "start": 1049,
            "end": 1115,
            "answer": "The resulting implementation will be easier to design and to debug"
        }
    ],
    [
        {
            "score": 0.09151910990476608,
            "start": 3877,
            "end": 3883,
            "answer": "HOLD=H"
        },
        {
            "score": 0.08780614286661148,
            "start": 2504,
            "end": 2513,
            "answer": "it counts"
        },
        {
            "score": 0.06010706350207329,
            "start": 2507,
            "end": 2513,
            "answer": "counts"
        },
        {
            "score": 0.04764218628406525,
            "start": 3877,
            "end": 3883,
            "answer": "HOLD=H"
        },
        {
            "score": 0.04690635949373245,
            "start": 4210,
            "end": 4218,
            "answer": "HOLD=H+."
        }
    ],
    [
        {
            "score": 0.014068813063204288,
            "start": 338,
            "end": 442,
            "answer": "Verifying that the implementation's behavior is correct is left as an exercise for the determined reader"
        },
        {
            "score": 0.0029683460015803576,
            "start": 338,
            "end": 393,
            "answer": "Verifying that the implementation's behavior is correct"
        },
        {
            "score": 0.0026808385737240314,
            "start": 397,
            "end": 442,
            "answer": "left as an exercise for the determined reader"
        },
        {
            "score": 0.0016183790285140276,
            "start": 190,
            "end": 442,
            "answer": "poorly chosen mapping from states to internal  state representation.  Below the table is a diagram of an implementation using that representation.  Verifying that the implementation's behavior is correct is left as an exercise for the determined reader"
        },
        {
            "score": 0.0013246180023998022,
            "start": 338,
            "end": 416,
            "answer": "Verifying that the implementation's behavior is correct is left as an exercise"
        }
    ],
    [
        {
            "score": 0.0009317661169916391,
            "start": 186,
            "end": 334,
            "answer": "memory abstraction and the types of memory most commonly used in digital systems, then examine how one can build memories (static RAMs)  using logic"
        },
        {
            "score": 0.0006538379238918424,
            "start": 186,
            "end": 204,
            "answer": "memory abstraction"
        },
        {
            "score": 0.000564072688575834,
            "start": 329,
            "end": 334,
            "answer": "logic"
        },
        {
            "score": 0.0004254352825228125,
            "start": 323,
            "end": 334,
            "answer": "using logic"
        },
        {
            "score": 0.000231637415708974,
            "start": 95,
            "end": 334,
            "answer": "slightly more detail than is available in the textbook.  We begin with a discussion of the memory abstraction and the types of memory most commonly used in digital systems, then examine how one can build memories (static RAMs)  using logic"
        }
    ],
    [
        {
            "score": 0.07666683942079544,
            "start": 3100,
            "end": 3170,
            "answer": "volatile, that is, both lose all data when the power supply is removed"
        },
        {
            "score": 0.07451178878545761,
            "start": 3100,
            "end": 3108,
            "answer": "volatile"
        },
        {
            "score": 0.07436157017946243,
            "start": 3119,
            "end": 3170,
            "answer": "both lose all data when the power supply is removed"
        },
        {
            "score": 0.05644833296537399,
            "start": 3085,
            "end": 3170,
            "answer": "Both types are volatile, that is, both lose all data when the power supply is removed"
        },
        {
            "score": 0.054861608892679214,
            "start": 3085,
            "end": 3108,
            "answer": "Both types are volatile"
        }
    ],
    [
        {
            "score": 0.10846371203660965,
            "start": 1774,
            "end": 1813,
            "answer": "more complicated than we have described"
        },
        {
            "score": 0.06633312255144119,
            "start": 399,
            "end": 437,
            "answer": "memory on the same chip as a processor"
        },
        {
            "score": 0.061552923172712326,
            "start": 1734,
            "end": 1813,
            "answer": "The actual operation of an SRAM cell is more complicated than we have described"
        },
        {
            "score": 0.0563206672668457,
            "start": 1774,
            "end": 1790,
            "answer": "more complicated"
        },
        {
            "score": 0.04965335130691528,
            "start": 395,
            "end": 437,
            "answer": "the memory on the same chip as a processor"
        }
    ],
    [
        {
            "score": 0.39785036444664,
            "start": 3050,
            "end": 3094,
            "answer": "to reduce the number of pins needed on chips"
        },
        {
            "score": 0.29477226734161377,
            "start": 3053,
            "end": 3094,
            "answer": "reduce the number of pins needed on chips"
        },
        {
            "score": 0.2831868529319763,
            "start": 3053,
            "end": 3094,
            "answer": "reduce the number of pins needed on chips"
        },
        {
            "score": 0.280643492937088,
            "start": 1081,
            "end": 1121,
            "answer": "acts as a pair of back-to-back inverters"
        },
        {
            "score": 0.27041006088256836,
            "start": 3050,
            "end": 3094,
            "answer": "to reduce the number of pins needed on chips"
        }
    ],
    [
        {
            "score": 0.5570656061172485,
            "start": 213,
            "end": 219,
            "answer": "denser"
        },
        {
            "score": 0.3986559808254242,
            "start": 2402,
            "end": 2420,
            "answer": "makes reads faster"
        },
        {
            "score": 0.12185736000537872,
            "start": 2408,
            "end": 2420,
            "answer": "reads faster"
        },
        {
            "score": 0.11608554422855377,
            "start": 213,
            "end": 250,
            "answer": "denser (has more bits per chip area)."
        },
        {
            "score": 0.10230109840631485,
            "start": 4537,
            "end": 4627,
            "answer": "internal timing and control logic that prevent races from overwriting an incorrect element"
        }
    ],
    [
        {
            "score": 0.1667679399251938,
            "start": 199,
            "end": 406,
            "answer": "automatically  identifying coins (dimes and quarters only), tracking the amount  of money entered by the user, accepting or rejecting  coins, and emitting a signal when a total of 35 cents has been  accepted"
        },
        {
            "score": 0.1327362358570099,
            "start": 199,
            "end": 308,
            "answer": "automatically  identifying coins (dimes and quarters only), tracking the amount  of money entered by the user"
        },
        {
            "score": 0.05381200835108757,
            "start": 199,
            "end": 339,
            "answer": "automatically  identifying coins (dimes and quarters only), tracking the amount  of money entered by the user, accepting or rejecting  coins"
        },
        {
            "score": 0.036843519657850266,
            "start": 199,
            "end": 231,
            "answer": "automatically  identifying coins"
        },
        {
            "score": 0.03520830720663071,
            "start": 199,
            "end": 258,
            "answer": "automatically  identifying coins (dimes and quarters only),"
        }
    ],
    [
        {
            "score": 0.3520333170890808,
            "start": 2063,
            "end": 2115,
            "answer": "indicates whether or not the coin should be accepted"
        },
        {
            "score": 0.17905302345752716,
            "start": 2063,
            "end": 2115,
            "answer": "indicates whether or not the coin should be accepted"
        },
        {
            "score": 0.08580146729946136,
            "start": 2063,
            "end": 2170,
            "answer": "indicates whether or not the coin should be accepted.  This signal  controls the servo that drives the gate"
        },
        {
            "score": 0.08200420439243317,
            "start": 2035,
            "end": 2115,
            "answer": "an output from the FSM, and indicates whether or not the coin should be accepted"
        },
        {
            "score": 0.08077939599752426,
            "start": 2035,
            "end": 2115,
            "answer": "an output from the FSM, and indicates whether or not the coin should be accepted"
        }
    ],
    [
        {
            "score": 0.08689490705728531,
            "start": 2981,
            "end": 3023,
            "answer": "simplify the logic needed to build the lab"
        },
        {
            "score": 0.08451178669929504,
            "start": 2978,
            "end": 3023,
            "answer": "to simplify the logic needed to build the lab"
        },
        {
            "score": 0.02747853472828865,
            "start": 2981,
            "end": 2999,
            "answer": "simplify the logic"
        },
        {
            "score": 0.02672492526471615,
            "start": 2978,
            "end": 2999,
            "answer": "to simplify the logic"
        },
        {
            "score": 0.024446289986371994,
            "start": 22,
            "end": 84,
            "answer": "We start by writing down states for a user's expected behavior"
        }
    ],
    [
        {
            "score": 0.025572389364242554,
            "start": 987,
            "end": 996,
            "answer": "any state"
        },
        {
            "score": 0.015881147235631943,
            "start": 4544,
            "end": 4553,
            "answer": "T=0& T=1&"
        },
        {
            "score": 0.008174261078238487,
            "start": 4544,
            "end": 4552,
            "answer": "T=0& T=1"
        },
        {
            "score": 0.005095580127090216,
            "start": 987,
            "end": 999,
            "answer": "any state   "
        },
        {
            "score": 0.0046457587741315365,
            "start": 4544,
            "end": 4551,
            "answer": "T=0& T="
        }
    ],
    [
        {
            "score": 0.00011553530930541456,
            "start": 1845,
            "end": 1852,
            "answer": "testing"
        },
        {
            "score": 1.7007745555019937e-05,
            "start": 1467,
            "end": 1507,
            "answer": "correctly implemented variant of our FSM"
        },
        {
            "score": 1.2682219676207751e-05,
            "start": 1833,
            "end": 1852,
            "answer": "PAID2.  For testing"
        },
        {
            "score": 8.82912991073681e-06,
            "start": 1465,
            "end": 1507,
            "answer": "a correctly implemented variant of our FSM"
        },
        {
            "score": 6.3324346228910144e-06,
            "start": 1467,
            "end": 1852,
            "answer": "correctly implemented variant of our FSM.  Our initialization sequence forces the FSM into a specific state regardless of its initial state.  And our test sequence crosses every transition arc leaving the six valid states.    In terms of T, the coin type, we initialize the FSM with the input sequence 001.  Notice that such a sequence takes any initial  state into PAID2.  For testing"
        }
    ],
    [
        {
            "score": 0.11216463148593903,
            "start": 197,
            "end": 205,
            "answer": "decoders"
        },
        {
            "score": 0.02584562636911869,
            "start": 197,
            "end": 256,
            "answer": "decoders as components that help us to implement our design"
        },
        {
            "score": 0.013533499091863632,
            "start": 197,
            "end": 219,
            "answer": "decoders as components"
        },
        {
            "score": 0.004513086285442114,
            "start": 209,
            "end": 256,
            "answer": "components that help us to implement our design"
        },
        {
            "score": 0.002363179111853242,
            "start": 209,
            "end": 219,
            "answer": "components"
        }
    ],
    [
        {
            "score": 0.0021520352456718683,
            "start": 4315,
            "end": 4414,
            "answer": "a signal to accept or reject an inserted coin as well as signals to release each of the three items"
        },
        {
            "score": 0.0016464043874293566,
            "start": 2743,
            "end": 2824,
            "answer": "those states with N<59 transition to states with value N+5 and accept the quarter"
        },
        {
            "score": 0.0016141985543072224,
            "start": 4372,
            "end": 4414,
            "answer": "signals to release each of the three items"
        },
        {
            "score": 0.0015518541913479567,
            "start": 4315,
            "end": 4828,
            "answer": "a signal to accept or reject an inserted coin as well as signals to release each of the three items.   For input to the FSM, we assume that a coin inserted in any given cycle  is classified and delivered to our FSM using the three-bit representation  shown to the right.  For item selection, we assume that the user has access to three buttons, B_1, B_2, and B_3, that indicate a desire to purchase the  corresponding item.  For output, the FSM must produce a signal A indicating whether a coin should be accepted"
        },
        {
            "score": 0.0013846727088093758,
            "start": 4315,
            "end": 4360,
            "answer": "a signal to accept or reject an inserted coin"
        }
    ],
    [
        {
            "score": 0.267230749130249,
            "start": 293,
            "end": 441,
            "answer": "generates a signal P whenever any of its four input lines is active and encodes the index of the highest active input as a two-bit unsigned number S"
        },
        {
            "score": 0.2066701352596283,
            "start": 293,
            "end": 360,
            "answer": "generates a signal P whenever any of its four input lines is active"
        },
        {
            "score": 0.07354764640331268,
            "start": 1032,
            "end": 1085,
            "answer": "indicating that the user is trying to make a purchase"
        },
        {
            "score": 0.06861443817615509,
            "start": 1008,
            "end": 1085,
            "answer": "it produces a signal P  indicating that the user is trying to make a purchase"
        },
        {
            "score": 0.059282105416059494,
            "start": 293,
            "end": 442,
            "answer": "generates a signal P whenever any of its four input lines is active and encodes the index of the highest active input as a two-bit unsigned number S."
        }
    ],
    [
        {
            "score": 0.00812220573425293,
            "start": 257,
            "end": 316,
            "answer": "subtracts the price of any purchase requested in that cycle"
        },
        {
            "score": 0.004875350743532181,
            "start": 257,
            "end": 276,
            "answer": "subtracts the price"
        },
        {
            "score": 0.0028601577505469322,
            "start": 257,
            "end": 292,
            "answer": "subtracts the price of any purchase"
        },
        {
            "score": 0.002783315721899271,
            "start": 208,
            "end": 249,
            "answer": "Each cycle, N is fed into a {6-bit} adder"
        },
        {
            "score": 0.0024955719709396362,
            "start": 257,
            "end": 646,
            "answer": "subtracts the price of any purchase requested in that cycle.   Recall that we chose to record item prices in registers.  We avoid the  need to negate prices before adding them by storing the negated prices in our registers.  Thus, the value of register PRICE1 is -P_1, the the value of register PRICE2 is -P_2, and the the value of register PRICE3 is -P_3.  The priority encoder's S signal"
        }
    ],
    [
        {
            "score": 0.10692676901817322,
            "start": 5746,
            "end": 5749,
            "answer": "P=1"
        },
        {
            "score": 0.006519173737615347,
            "start": 3068,
            "end": 3090,
            "answer": "the current state FXGC"
        },
        {
            "score": 0.005149665754288435,
            "start": 5738,
            "end": 5749,
            "answer": "outputs P=1"
        },
        {
            "score": 0.004952735733240843,
            "start": 5746,
            "end": 5748,
            "answer": "P="
        },
        {
            "score": 0.004717745818197727,
            "start": 3072,
            "end": 3090,
            "answer": "current state FXGC"
        }
    ],
    [
        {
            "score": 0.17601707577705383,
            "start": 1331,
            "end": 1435,
            "answer": "For safety reasons, the controller must ensure that the lights on one or both roads are red at all times"
        },
        {
            "score": 0.1633526235818863,
            "start": 1331,
            "end": 1349,
            "answer": "For safety reasons"
        },
        {
            "score": 0.10861895978450775,
            "start": 1335,
            "end": 1435,
            "answer": "safety reasons, the controller must ensure that the lights on one or both roads are red at all times"
        },
        {
            "score": 0.10305456817150116,
            "start": 3428,
            "end": 3434,
            "answer": "safety"
        },
        {
            "score": 0.10080380737781525,
            "start": 1335,
            "end": 1349,
            "answer": "safety reasons"
        }
    ],
    [
        {
            "score": 0.02494741603732109,
            "start": 1256,
            "end": 1274,
            "answer": "more general model"
        },
        {
            "score": 0.022147420793771744,
            "start": 1186,
            "end": 1248,
            "answer": "the FSM executes a program specified by bits stored in  memory"
        },
        {
            "score": 0.019441228359937668,
            "start": 1186,
            "end": 1274,
            "answer": "the FSM executes a program specified by bits stored in  memory.  This more general model"
        },
        {
            "score": 0.019318563863635063,
            "start": 1190,
            "end": 1248,
            "answer": "FSM executes a program specified by bits stored in  memory"
        },
        {
            "score": 0.016958031803369522,
            "start": 1190,
            "end": 1274,
            "answer": "FSM executes a program specified by bits stored in  memory.  This more general model"
        }
    ],
    [
        {
            "score": 0.6891088485717773,
            "start": 649,
            "end": 654,
            "answer": "three"
        },
        {
            "score": 0.19579683244228363,
            "start": 649,
            "end": 664,
            "answer": "three variables"
        },
        {
            "score": 0.06370057910680771,
            "start": 890,
            "end": 911,
            "answer": "10 separate variables"
        },
        {
            "score": 0.02623024210333824,
            "start": 635,
            "end": 654,
            "answer": "The code uses three"
        },
        {
            "score": 0.01704048179090023,
            "start": 649,
            "end": 665,
            "answer": "three variables."
        }
    ],
    [
        {
            "score": 0.16620156168937683,
            "start": 2920,
            "end": 3041,
            "answer": "external logic filling the memory (the array of integer values), executing the FSM ``code,'' and then checking the answer"
        },
        {
            "score": 0.0651753842830658,
            "start": 2920,
            "end": 2982,
            "answer": "external logic filling the memory (the array of integer values"
        },
        {
            "score": 0.052816037088632584,
            "start": 2920,
            "end": 2934,
            "answer": "external logic"
        },
        {
            "score": 0.04762620851397514,
            "start": 2920,
            "end": 2984,
            "answer": "external logic filling the memory (the array of integer values),"
        },
        {
            "score": 0.02786133997142315,
            "start": 2935,
            "end": 3041,
            "answer": "filling the memory (the array of integer values), executing the FSM ``code,'' and then checking the answer"
        }
    ],
    [
        {
            "score": 0.3110082149505615,
            "start": 4414,
            "end": 4486,
            "answer": "indicates that the serial comparator is on its last cycle of  comparison"
        },
        {
            "score": 0.07399078458547592,
            "start": 4408,
            "end": 4486,
            "answer": "which indicates that the serial comparator is on its last cycle of  comparison"
        },
        {
            "score": 0.02316390350461006,
            "start": 3819,
            "end": 3873,
            "answer": "compares the value in a register with a fixed constant"
        },
        {
            "score": 0.02096884697675705,
            "start": 4433,
            "end": 4486,
            "answer": "serial comparator is on its last cycle of  comparison"
        },
        {
            "score": 0.018442586064338684,
            "start": 4429,
            "end": 4486,
            "answer": "the serial comparator is on its last cycle of  comparison"
        }
    ],
    [
        {
            "score": 0.5492283701896667,
            "start": 3043,
            "end": 3074,
            "answer": "at the end of every clock cycle"
        },
        {
            "score": 0.13301609456539154,
            "start": 3046,
            "end": 3074,
            "answer": "the end of every clock cycle"
        },
        {
            "score": 0.11974489688873291,
            "start": 3050,
            "end": 3074,
            "answer": "end of every clock cycle"
        },
        {
            "score": 0.042009785771369934,
            "start": 3057,
            "end": 3074,
            "answer": "every clock cycle"
        },
        {
            "score": 0.016828788444399834,
            "start": 3043,
            "end": 3075,
            "answer": "at the end of every clock cycle,"
        }
    ],
    [
        {
            "score": 0.38217589259147644,
            "start": 233,
            "end": 276,
            "answer": "any valid bit pattern has exactly one 1 bit"
        },
        {
            "score": 0.061915844678878784,
            "start": 233,
            "end": 334,
            "answer": "any valid bit pattern has exactly one 1 bit.  In other words, we use five flip-flops instead of three"
        },
        {
            "score": 0.0605696365237236,
            "start": 233,
            "end": 317,
            "answer": "any valid bit pattern has exactly one 1 bit.  In other words, we use five flip-flops"
        },
        {
            "score": 0.050678595900535583,
            "start": 237,
            "end": 276,
            "answer": "valid bit pattern has exactly one 1 bit"
        },
        {
            "score": 0.02693347819149494,
            "start": 224,
            "end": 276,
            "answer": "in which any valid bit pattern has exactly one 1 bit"
        }
    ],
    [
        {
            "score": 0.03189200907945633,
            "start": 1,
            "end": 39,
            "answer": "Extending Keyless Entry with a Timeout"
        },
        {
            "score": 0.028892874717712402,
            "start": 0,
            "end": 39,
            "answer": "{Extending Keyless Entry with a Timeout"
        },
        {
            "score": 0.015617262572050095,
            "start": 267,
            "end": 457,
            "answer": "to illustrate how we can make use of components such as registers and counters as building blocks for our FSMs without fully expanding the design to explicitly illustrate all possible states"
        },
        {
            "score": 0.011289103887975216,
            "start": 267,
            "end": 458,
            "answer": "to illustrate how we can make use of components such as registers and counters as building blocks for our FSMs without fully expanding the design to explicitly illustrate all possible states."
        },
        {
            "score": 0.008959916420280933,
            "start": 1,
            "end": 40,
            "answer": "Extending Keyless Entry with a Timeout}"
        }
    ],
    [
        {
            "score": 0.01128578931093216,
            "start": 2003,
            "end": 2025,
            "answer": "simple counter designs"
        },
        {
            "score": 0.003958155866712332,
            "start": 2010,
            "end": 2025,
            "answer": "counter designs"
        },
        {
            "score": 0.0031615968327969313,
            "start": 2003,
            "end": 2009,
            "answer": "simple"
        },
        {
            "score": 0.002452098298817873,
            "start": 1990,
            "end": 2025,
            "answer": "a handful of simple counter designs"
        },
        {
            "score": 0.002268304117023945,
            "start": 2003,
            "end": 2017,
            "answer": "simple counter"
        }
    ],
    [
        {
            "score": 0.4077170193195343,
            "start": 862,
            "end": 868,
            "answer": "slower"
        },
        {
            "score": 0.17831723392009735,
            "start": 854,
            "end": 868,
            "answer": "usually slower"
        },
        {
            "score": 0.09052565693855286,
            "start": 741,
            "end": 868,
            "answer": "The area needed for a serial design is usually much less than for a bit-sliced design, but such a design is also usually slower"
        },
        {
            "score": 0.07321225106716156,
            "start": 832,
            "end": 868,
            "answer": "such a design is also usually slower"
        },
        {
            "score": 0.05776359140872955,
            "start": 1752,
            "end": 1815,
            "answer": "single copy of the bit slice logic, M+Q flip-flops, and M gates"
        }
    ],
    [
        {
            "score": 0.07554300874471664,
            "start": 5627,
            "end": 5708,
            "answer": "the new design is identical, meaning that we finish a comparison in half the time"
        },
        {
            "score": 0.029954567551612854,
            "start": 5593,
            "end": 5708,
            "answer": "In terms of gate delays, however, the new design is identical, meaning that we finish a comparison in half the time"
        },
        {
            "score": 0.027867689728736877,
            "start": 5669,
            "end": 5708,
            "answer": "we finish a comparison in half the time"
        },
        {
            "score": 0.024490242823958397,
            "start": 2351,
            "end": 2414,
            "answer": "The performance of the serial design is likely to be much worse"
        },
        {
            "score": 0.021300623193383217,
            "start": 2355,
            "end": 2414,
            "answer": "performance of the serial design is likely to be much worse"
        }
    ],
    [
        {
            "score": 0.15676262974739075,
            "start": 66,
            "end": 116,
            "answer": "a model for understanding the behavior of a system"
        },
        {
            "score": 0.11522173136472702,
            "start": 66,
            "end": 276,
            "answer": "a model for understanding the behavior of a system by describing the system as occupying one of a finite set of states, moving between these states in response to external inputs, and producing external outputs"
        },
        {
            "score": 0.09857265651226044,
            "start": 66,
            "end": 184,
            "answer": "a model for understanding the behavior of a system by describing the system as occupying one of a finite set of states"
        },
        {
            "score": 0.02324214205145836,
            "start": 63,
            "end": 116,
            "answer": "is a model for understanding the behavior of a system"
        },
        {
            "score": 0.019955936819314957,
            "start": 68,
            "end": 116,
            "answer": "model for understanding the behavior of a system"
        }
    ],
    [
        {
            "score": 0.03940758854150772,
            "start": 179,
            "end": 253,
            "answer": "not all flip-flops in a counter are required to use  the same clock signal"
        },
        {
            "score": 0.03570479527115822,
            "start": 179,
            "end": 323,
            "answer": "not all flip-flops in a counter are required to use  the same clock signal.  A counter in which all flip-flops do  utilize the same clock signal"
        },
        {
            "score": 0.020890701562166214,
            "start": 275,
            "end": 323,
            "answer": "all flip-flops do  utilize the same clock signal"
        },
        {
            "score": 0.009771531447768211,
            "start": 129,
            "end": 253,
            "answer": "Not all counters are synchronous. In other words, not all flip-flops in a counter are required to use  the same clock signal"
        },
        {
            "score": 0.008853384293615818,
            "start": 129,
            "end": 323,
            "answer": "Not all counters are synchronous. In other words, not all flip-flops in a counter are required to use  the same clock signal.  A counter in which all flip-flops do  utilize the same clock signal"
        }
    ],
    [
        {
            "score": 0.12560895085334778,
            "start": 19,
            "end": 321,
            "answer": "A second class of counter drives some of its flip-flops with a clock signal and feeds flip-flop outputs into the clock inputs of its remaining flip-flops, possibly through additional logic.  Such a counter is called a { ripple counter}, because the effect of a clock edge ripples through the flip-flops"
        },
        {
            "score": 0.11846437305212021,
            "start": 264,
            "end": 321,
            "answer": "the effect of a clock edge ripples through the flip-flops"
        },
        {
            "score": 0.1117112785577774,
            "start": 1420,
            "end": 1427,
            "answer": "{4-bit}"
        },
        {
            "score": 0.08785511553287506,
            "start": 1421,
            "end": 1427,
            "answer": "4-bit}"
        },
        {
            "score": 0.08000496029853821,
            "start": 1420,
            "end": 1426,
            "answer": "{4-bit"
        }
    ],
    [
        {
            "score": 0.44874247908592224,
            "start": 1779,
            "end": 1786,
            "answer": "voltage"
        },
        {
            "score": 0.17476150393486023,
            "start": 1775,
            "end": 1786,
            "answer": "the voltage"
        },
        {
            "score": 0.17385129630565643,
            "start": 1775,
            "end": 1847,
            "answer": "the voltage difference is removed, and the  circuit uses no power at all"
        },
        {
            "score": 0.13607744872570038,
            "start": 1779,
            "end": 1847,
            "answer": "voltage difference is removed, and the  circuit uses no power at all"
        },
        {
            "score": 0.07735008001327515,
            "start": 1779,
            "end": 1797,
            "answer": "voltage difference"
        }
    ],
    [
        {
            "score": 0.0810421034693718,
            "start": 850,
            "end": 974,
            "answer": "input bits effectively serve  as additional system state, which means that the number of internal  state bits can be reduced"
        },
        {
            "score": 0.0515894740819931,
            "start": 850,
            "end": 906,
            "answer": "input bits effectively serve  as additional system state"
        },
        {
            "score": 0.025274265557527542,
            "start": 760,
            "end": 974,
            "answer": "the benefit of using input signals to calculate outputs (the Mealy machine model) is that input bits effectively serve  as additional system state, which means that the number of internal  state bits can be reduced"
        },
        {
            "score": 0.02241605892777443,
            "start": 408,
            "end": 974,
            "answer": "more general model used almost universally in hardware design, Mealy machines.  What is the difference?  In a { Moore machine}, outputs depend only on the internal state bits of the FSM (the values stored in the flip-flops). In a { Mealy machine}, outputs may be expressed as functions both of internal state and FSM inputs.  As we illustrate shortly, the benefit of using input signals to calculate outputs (the Mealy machine model) is that input bits effectively serve  as additional system state, which means that the number of internal  state bits can be reduced"
        },
        {
            "score": 0.016088997945189476,
            "start": 760,
            "end": 906,
            "answer": "the benefit of using input signals to calculate outputs (the Mealy machine model) is that input bits effectively serve  as additional system state"
        }
    ],
    [
        {
            "score": 0.014623711816966534,
            "start": 5216,
            "end": 5355,
            "answer": "Explain the difference between the Moore and Mealy machine models,  as well as why you might find each of them useful when designing an FSM"
        },
        {
            "score": 0.01159083005040884,
            "start": 5295,
            "end": 5355,
            "answer": "why you might find each of them useful when designing an FSM"
        },
        {
            "score": 0.008069127798080444,
            "start": 5215,
            "end": 5355,
            "answer": "{Explain the difference between the Moore and Mealy machine models,  as well as why you might find each of them useful when designing an FSM"
        },
        {
            "score": 0.004772523883730173,
            "start": 5199,
            "end": 5355,
            "answer": "{}{{}{} {}{}{}  {Explain the difference between the Moore and Mealy machine models,  as well as why you might find each of them useful when designing an FSM"
        },
        {
            "score": 0.004335371777415276,
            "start": 5216,
            "end": 5333,
            "answer": "Explain the difference between the Moore and Mealy machine models,  as well as why you might find each of them useful"
        }
    ],
    [
        {
            "score": 0.2995431423187256,
            "start": 845,
            "end": 850,
            "answer": "sound"
        },
        {
            "score": 0.2522663474082947,
            "start": 835,
            "end": 850,
            "answer": "Employing sound"
        },
        {
            "score": 0.2148999720811844,
            "start": 845,
            "end": 868,
            "answer": "sound design principles"
        },
        {
            "score": 0.18098239600658417,
            "start": 835,
            "end": 868,
            "answer": "Employing sound design principles"
        },
        {
            "score": 0.003112061182036996,
            "start": 845,
            "end": 857,
            "answer": "sound design"
        }
    ],
    [
        {
            "score": 0.6025804877281189,
            "start": 1544,
            "end": 1568,
            "answer": "easy to fetch and decode"
        },
        {
            "score": 0.15922750532627106,
            "start": 1544,
            "end": 1568,
            "answer": "easy to fetch and decode"
        },
        {
            "score": 0.05498276278376579,
            "start": 2866,
            "end": 2882,
            "answer": "more flexibility"
        },
        {
            "score": 0.027754487469792366,
            "start": 1544,
            "end": 2043,
            "answer": "easy to fetch and decode.  A processor knows in advance how many bits must be fetched to fetch a full instruction; fetching the opcode and mode fields in order to decide how many more bits are necessary to complete the instruction may require more than one cycle.  Fixing the time necessary for instruction fetch also simplifies pipelining.  Finally, fixed-length instructions simplify the datapath by restricting instructions to the size of the bus and always fetching properly aligned instructions"
        },
        {
            "score": 0.022594548761844635,
            "start": 2305,
            "end": 2338,
            "answer": "saving both memory and disk space"
        }
    ],
    [
        {
            "score": 0.07927493005990982,
            "start": 4308,
            "end": 4327,
            "answer": "use fewer registers"
        },
        {
            "score": 0.07705185562372208,
            "start": 1506,
            "end": 1552,
            "answer": "only loads and stores can use memory addresses"
        },
        {
            "score": 0.06347665935754776,
            "start": 4312,
            "end": 4327,
            "answer": "fewer registers"
        },
        {
            "score": 0.03644204139709473,
            "start": 1506,
            "end": 1593,
            "answer": "only loads and stores can use memory addresses; all other operations use only registers"
        },
        {
            "score": 0.029441965743899345,
            "start": 1511,
            "end": 1552,
            "answer": "loads and stores can use memory addresses"
        }
    ],
    [
        {
            "score": 0.044327348470687866,
            "start": 1445,
            "end": 1511,
            "answer": "a destination for operations performed only for their side-effects"
        },
        {
            "score": 0.038645267486572266,
            "start": 1405,
            "end": 1511,
            "answer": "serves both as a useful constant and as a destination for operations performed only for their side-effects"
        },
        {
            "score": 0.038620010018348694,
            "start": 1375,
            "end": 1511,
            "answer": "The register is read-only and serves both as a useful constant and as a destination for operations performed only for their side-effects"
        },
        {
            "score": 0.03704323247075081,
            "start": 1420,
            "end": 1511,
            "answer": "a useful constant and as a destination for operations performed only for their side-effects"
        },
        {
            "score": 0.0348060317337513,
            "start": 1442,
            "end": 1511,
            "answer": "as a destination for operations performed only for their side-effects"
        }
    ],
    [
        {
            "score": 0.18028521537780762,
            "start": 1940,
            "end": 2004,
            "answer": "deep pipelines and multiple instruction issues in a single cycle"
        },
        {
            "score": 0.0621868334710598,
            "start": 1940,
            "end": 2042,
            "answer": "deep pipelines and multiple instruction issues in a single cycle (termed superscalar implementations),"
        },
        {
            "score": 0.060010820627212524,
            "start": 1782,
            "end": 1837,
            "answer": "fixed-length instructions and a load-store architecture"
        },
        {
            "score": 0.056753452867269516,
            "start": 1940,
            "end": 1986,
            "answer": "deep pipelines and multiple instruction issues"
        },
        {
            "score": 0.04175332561135292,
            "start": 1300,
            "end": 1837,
            "answer": "performance advantage of fixed-length instructions, which simplifies the datapath and enables pipelining, on the other hand, was  attractive.  Researchers leveraged these ideas, which had been floating around the research community (and had appeared in some commercial architectures) to create { reduced instruction set computers}, or { RISC} machines.  The competing VAXen were labeled { CISC} machines, which stands for { complex instruction set computers}.  RISC machines employ fixed-length instructions and a load-store architecture"
        }
    ],
    [
        {
            "score": 0.032687678933143616,
            "start": 1881,
            "end": 1936,
            "answer": "how information is passed between a caller and a callee"
        },
        {
            "score": 0.010437041521072388,
            "start": 1885,
            "end": 1936,
            "answer": "information is passed between a caller and a callee"
        },
        {
            "score": 0.0076758344657719135,
            "start": 1900,
            "end": 1936,
            "answer": "passed between a caller and a callee"
        },
        {
            "score": 0.004070949275046587,
            "start": 1881,
            "end": 2171,
            "answer": "how information is passed between a caller and a callee.  In particular, it specifies the following: where arguments must be placed, either in registers or in specific stack memory locations; which registers can be used or changed by the procedure; and where any return value must be placed"
        },
        {
            "score": 0.0036280739586800337,
            "start": 1871,
            "end": 1936,
            "answer": "specifies how information is passed between a caller and a callee"
        }
    ],
    [
        {
            "score": 0.29295289516448975,
            "start": 1195,
            "end": 1209,
            "answer": "asynchronously"
        },
        {
            "score": 0.2797411382198334,
            "start": 244,
            "end": 297,
            "answer": "asynchronous interruptions generated by other devices"
        },
        {
            "score": 0.21097232401371002,
            "start": 1195,
            "end": 1237,
            "answer": "asynchronously with respect to the program"
        },
        {
            "score": 0.1216728687286377,
            "start": 244,
            "end": 270,
            "answer": "asynchronous interruptions"
        },
        {
            "score": 0.101837657392025,
            "start": 244,
            "end": 414,
            "answer": "asynchronous interruptions generated by other devices, including disk drives, printers, network cards, video cards, keyboards, mice, and any number of other possibilities"
        }
    ],
    [
        {
            "score": 0.10635529458522797,
            "start": 1251,
            "end": 1315,
            "answer": "they may be kept in general-purpose registers or not kept at all"
        },
        {
            "score": 0.0745554268360138,
            "start": 1899,
            "end": 2044,
            "answer": "the first has the shortest instructions, the second is the most general and simplest to implement, and the third requires the fewest instructions"
        },
        {
            "score": 0.0431663915514946,
            "start": 1899,
            "end": 1996,
            "answer": "the first has the shortest instructions, the second is the most general and simplest to implement"
        },
        {
            "score": 0.030349846929311752,
            "start": 1271,
            "end": 1315,
            "answer": "general-purpose registers or not kept at all"
        },
        {
            "score": 0.025561871007084846,
            "start": 1256,
            "end": 1315,
            "answer": "may be kept in general-purpose registers or not kept at all"
        }
    ],
    [
        {
            "score": 0.06189722567796707,
            "start": 1560,
            "end": 1647,
            "answer": "to store the remaining two values on the stack and to restore them when they are needed"
        },
        {
            "score": 0.02427835762500763,
            "start": 1560,
            "end": 1606,
            "answer": "to store the remaining two values on the stack"
        },
        {
            "score": 0.02326979674398899,
            "start": 1563,
            "end": 1647,
            "answer": "store the remaining two values on the stack and to restore them when they are needed"
        },
        {
            "score": 0.022378278896212578,
            "start": 1611,
            "end": 1647,
            "answer": "to restore them when they are needed"
        },
        {
            "score": 0.014371825382113457,
            "start": 929,
            "end": 951,
            "answer": "generated by compilers"
        }
    ],
    [
        {
            "score": 0.03194877505302429,
            "start": 1044,
            "end": 1144,
            "answer": "separates I/O ports from memory addresses by using distinct instructions for each class of operation"
        },
        {
            "score": 0.026472585275769234,
            "start": 943,
            "end": 1144,
            "answer": "two sets of special-purpose registers can be separated by the ISA, such an { independent I/O} system separates I/O ports from memory addresses by using distinct instructions for each class of operation"
        },
        {
            "score": 0.0262595284730196,
            "start": 1054,
            "end": 1144,
            "answer": "I/O ports from memory addresses by using distinct instructions for each class of operation"
        },
        {
            "score": 0.021257255226373672,
            "start": 1044,
            "end": 1427,
            "answer": "separates I/O ports from memory addresses by using distinct instructions for each class of operation.  Alternatively, device registers can be accessed using the same load and store instructions as are used to access memory.  This approach, known as { memory-mapped I/O}, requires no new instructions for I/O, but demands that a region of the memory address space be set aside for I/O"
        },
        {
            "score": 0.018820831552147865,
            "start": 1315,
            "end": 1427,
            "answer": "requires no new instructions for I/O, but demands that a region of the memory address space be set aside for I/O"
        }
    ],
    [
        {
            "score": 0.03773123398423195,
            "start": 1233,
            "end": 1261,
            "answer": "Other von Neumann components"
        },
        {
            "score": 0.015898067504167557,
            "start": 1233,
            "end": 1641,
            "answer": "Other von Neumann components provide inputs to the control unit.  The memory unit, for example, contains the instructions and data on which  the program executes.    The processing unit contains a register file and condition  codes (N, Z, and P for the {LC-3} ISA).    The outputs of the control unit are signals that control operation of the datapath: the processing unit, the memory, and the I/O interfaces"
        },
        {
            "score": 0.00919297244399786,
            "start": 1233,
            "end": 1261,
            "answer": "Other von Neumann components"
        },
        {
            "score": 0.006706607528030872,
            "start": 1239,
            "end": 1261,
            "answer": "von Neumann components"
        },
        {
            "score": 0.005808215122669935,
            "start": 1538,
            "end": 1641,
            "answer": "signals that control operation of the datapath: the processing unit, the memory, and the I/O interfaces"
        }
    ],
    [
        {
            "score": 4.208320387988351e-05,
            "start": 2478,
            "end": 2480,
            "answer": "25"
        },
        {
            "score": 2.399948425590992e-05,
            "start": 2478,
            "end": 2558,
            "answer": "25 control signals for the datapath without support for privilege and interrupts"
        },
        {
            "score": 2.093991861329414e-05,
            "start": 2446,
            "end": 2480,
            "answer": "The total of all groups is thus 25"
        },
        {
            "score": 1.474176679039374e-05,
            "start": 2478,
            "end": 2513,
            "answer": "25 control signals for the datapath"
        },
        {
            "score": 1.2007951227133162e-05,
            "start": 2340,
            "end": 2480,
            "answer": "10. The last two groups of signals control the ALU and the memory,  requiring a total of 4 more signals.  The total of all groups is thus 25"
        }
    ],
    [
        {
            "score": 0.5697228908538818,
            "start": 3205,
            "end": 3208,
            "answer": "RTL"
        },
        {
            "score": 0.10478629916906357,
            "start": 3201,
            "end": 3208,
            "answer": "the RTL"
        },
        {
            "score": 0.04975327104330063,
            "start": 462,
            "end": 476,
            "answer": "state number 1"
        },
        {
            "score": 0.023411834612488747,
            "start": 475,
            "end": 476,
            "answer": "1"
        },
        {
            "score": 0.018224112689495087,
            "start": 459,
            "end": 476,
            "answer": "---state number 1"
        }
    ],
    [
        {
            "score": 0.009576920419931412,
            "start": 354,
            "end": 383,
            "answer": "register load control signals"
        },
        {
            "score": 0.004819695837795734,
            "start": 23,
            "end": 383,
            "answer": "LDR}  As a second example, consider the first state in the sequence that  implements the LDR instruction---state number 6 in the figure on the  previous page.  The RTL for the state is: MAR  BaseR + off6, but BaseR is abbreviated to ``B'' in the state diagram.  What is the control word for this state?  Let's again begin with the register load control signals"
        },
        {
            "score": 0.002107890322804451,
            "start": 23,
            "end": 26,
            "answer": "LDR"
        },
        {
            "score": 0.001891594030894339,
            "start": 354,
            "end": 441,
            "answer": "register load control signals.  Only the MAR is written by the RTL, so we need LD.MAR=1"
        },
        {
            "score": 0.0018049486679956317,
            "start": 350,
            "end": 383,
            "answer": "the register load control signals"
        }
    ],
    [
        {
            "score": 0.0021285240072757006,
            "start": 5564,
            "end": 5567,
            "answer": "two"
        },
        {
            "score": 0.0015654104063287377,
            "start": 5564,
            "end": 5567,
            "answer": "two"
        },
        {
            "score": 0.0008172335219569504,
            "start": 5182,
            "end": 5567,
            "answer": "five bits of IR instead of four as input to our logic.  How many datapath status signals are needed?  When the control unit accesses memory, it must wait until the  memory finishes the access, as indicated by a memory ready signal R. And the control unit must implement the conditional part of conditional branches, for which it uses the datapath's branch enable signal BEN.  These two"
        },
        {
            "score": 0.00047911403817124665,
            "start": 3462,
            "end": 3487,
            "answer": "some datapath status bits"
        },
        {
            "score": 0.00021615238802041858,
            "start": 5182,
            "end": 5567,
            "answer": "five bits of IR instead of four as input to our logic.  How many datapath status signals are needed?  When the control unit accesses memory, it must wait until the  memory finishes the access, as indicated by a memory ready signal R. And the control unit must implement the conditional part of conditional branches, for which it uses the datapath's branch enable signal BEN.  These two"
        }
    ],
    [
        {
            "score": 0.030514581128954887,
            "start": 749,
            "end": 771,
            "answer": "easier to modify later"
        },
        {
            "score": 0.02444159798324108,
            "start": 738,
            "end": 771,
            "answer": "makes them easier to modify later"
        },
        {
            "score": 0.01756628043949604,
            "start": 424,
            "end": 771,
            "answer": "So long as the value of m is fairly small, the memory (especially SRAM) can be fast.  Synthesis tools (or hard work) can, of course, produce smaller designs that use fewer gates.  Actually, tools may be able to optimize a fixed design expressed as read-only memory, too.  But designing the functions with a memory makes them easier to modify later"
        },
        {
            "score": 0.01653311587870121,
            "start": 3300,
            "end": 3324,
            "answer": "If we add a little logic"
        },
        {
            "score": 0.009576652199029922,
            "start": 388,
            "end": 771,
            "answer": "filling in the bits of the memory.  So long as the value of m is fairly small, the memory (especially SRAM) can be fast.  Synthesis tools (or hard work) can, of course, produce smaller designs that use fewer gates.  Actually, tools may be able to optimize a fixed design expressed as read-only memory, too.  But designing the functions with a memory makes them easier to modify later"
        }
    ],
    [
        {
            "score": 0.04277432709932327,
            "start": 163,
            "end": 194,
            "answer": "Does it  remind you of anything"
        },
        {
            "score": 0.014827772043645382,
            "start": 172,
            "end": 194,
            "answer": "remind you of anything"
        },
        {
            "score": 0.010670973919332027,
            "start": 163,
            "end": 195,
            "answer": "Does it  remind you of anything?"
        },
        {
            "score": 0.007852657698094845,
            "start": 168,
            "end": 194,
            "answer": "it  remind you of anything"
        },
        {
            "score": 0.007414954248815775,
            "start": 186,
            "end": 194,
            "answer": "anything"
        }
    ],
    [
        {
            "score": 0.5719283819198608,
            "start": 107,
            "end": 152,
            "answer": "to protect against accidental changes to bits"
        },
        {
            "score": 0.3778190612792969,
            "start": 110,
            "end": 152,
            "answer": "protect against accidental changes to bits"
        },
        {
            "score": 0.0029626325704157352,
            "start": 107,
            "end": 456,
            "answer": "to protect against accidental changes to bits. Today, such representations are used in almost every type of storage system, from bits on a chip to main memory to disk to archival tapes.  We begin our discussion with examples of representations in which some  bit patterns have no meaning, then consider what happens when a bit  changes accidentally."
        },
        {
            "score": 0.002962630707770586,
            "start": 107,
            "end": 153,
            "answer": "to protect against accidental changes to bits."
        },
        {
            "score": 0.0029625899624079466,
            "start": 107,
            "end": 292,
            "answer": "to protect against accidental changes to bits. Today, such representations are used in almost every type of storage system, from bits on a chip to main memory to disk to archival tapes."
        }
    ],
    [
        {
            "score": 0.006237572059035301,
            "start": 2037,
            "end": 2076,
            "answer": "five bits are used to encode each digit"
        },
        {
            "score": 0.00476669380441308,
            "start": 1945,
            "end": 2076,
            "answer": "The third example of decimal digit representations is a {2-out-of-5} code.  In such a code, five bits are used to encode each digit"
        },
        {
            "score": 0.0027050103526562452,
            "start": 1966,
            "end": 2076,
            "answer": "decimal digit representations is a {2-out-of-5} code.  In such a code, five bits are used to encode each digit"
        },
        {
            "score": 0.0025862783659249544,
            "start": 2037,
            "end": 2123,
            "answer": "five bits are used to encode each digit.    Only patterns with exactly two 1s are used"
        },
        {
            "score": 0.001976409461349249,
            "start": 1945,
            "end": 2123,
            "answer": "The third example of decimal digit representations is a {2-out-of-5} code.  In such a code, five bits are used to encode each digit.    Only patterns with exactly two 1s are used"
        }
    ],
    [
        {
            "score": 0.05089626461267471,
            "start": 2289,
            "end": 2335,
            "answer": "the pattern with no errors  has exactly two 1s"
        },
        {
            "score": 0.04299194738268852,
            "start": 2247,
            "end": 2335,
            "answer": "Regardless of which digit is represented, the pattern with no errors  has exactly two 1s"
        },
        {
            "score": 0.028533391654491425,
            "start": 1410,
            "end": 1411,
            "answer": "7"
        },
        {
            "score": 0.012694026343524456,
            "start": 2187,
            "end": 2335,
            "answer": " What if the system needs to represent a different digit?   Regardless of which digit is represented, the pattern with no errors  has exactly two 1s"
        },
        {
            "score": 0.012431077659130096,
            "start": 2187,
            "end": 2187,
            "answer": ""
        }
    ],
    [
        {
            "score": 0.14675931632518768,
            "start": 1624,
            "end": 1673,
            "answer": "ensures that any single bit error can be detected"
        },
        {
            "score": 0.08166971057653427,
            "start": 982,
            "end": 1105,
            "answer": "we can ensure that the count of 1s is odd (called { odd parity}) or even (called { even parity}) for all values represented"
        },
        {
            "score": 0.07282258570194244,
            "start": 1637,
            "end": 1673,
            "answer": "any single bit error can be detected"
        },
        {
            "score": 0.03656972572207451,
            "start": 989,
            "end": 1105,
            "answer": "ensure that the count of 1s is odd (called { odd parity}) or even (called { even parity}) for all values represented"
        },
        {
            "score": 0.02658284641802311,
            "start": 912,
            "end": 1105,
            "answer": "selecting the parity bit's value  appropriately for each bit pattern, we can ensure that the count of 1s is odd (called { odd parity}) or even (called { even parity}) for all values represented"
        }
    ],
    [
        {
            "score": 0.001026324462145567,
            "start": 1638,
            "end": 1645,
            "answer": "minimum"
        },
        {
            "score": 0.00011366416583769023,
            "start": 2703,
            "end": 2704,
            "answer": "2"
        },
        {
            "score": 0.00010604125418467447,
            "start": 1464,
            "end": 1645,
            "answer": "minimum Hamming distance between any pair of code words used by the  representation.  The result is called the { Hamming distance of the  representation}, and represents the minimum"
        },
        {
            "score": 8.685654756845906e-05,
            "start": 2927,
            "end": 2936,
            "answer": "up to d-1"
        },
        {
            "score": 8.058787352638319e-05,
            "start": 2927,
            "end": 2947,
            "answer": "up to d-1 bit errors"
        }
    ],
    [
        {
            "score": 0.2700748145580292,
            "start": 3490,
            "end": 3558,
            "answer": "selecting the unique value identified by the associated neighborhood"
        },
        {
            "score": 0.22709980607032776,
            "start": 20,
            "end": 39,
            "answer": "Detection of errors"
        },
        {
            "score": 0.1795962005853653,
            "start": 3486,
            "end": 3558,
            "answer": "by  selecting the unique value identified by the associated neighborhood"
        },
        {
            "score": 0.14599741995334625,
            "start": 3439,
            "end": 3558,
            "answer": "The digital system can then correct the errors by  selecting the unique value identified by the associated neighborhood"
        },
        {
            "score": 0.13998737931251526,
            "start": 1855,
            "end": 1895,
            "answer": "if we assume that fewer bit errors occur"
        }
    ],
    [
        {
            "score": 0.8402637839317322,
            "start": 208,
            "end": 209,
            "answer": "3"
        },
        {
            "score": 0.04590866342186928,
            "start": 2703,
            "end": 2728,
            "answer": "0& 0000& 0& 0& 0& 0000000"
        },
        {
            "score": 0.027932602912187576,
            "start": 191,
            "end": 209,
            "answer": "Hamming distance 3"
        },
        {
            "score": 0.02165965922176838,
            "start": 2703,
            "end": 2711,
            "answer": "0& 0000&"
        },
        {
            "score": 0.018556667491793633,
            "start": 2703,
            "end": 2755,
            "answer": "0& 0000& 0& 0& 0& 0000000  1& 0001& 0& 1& 1& 0000111"
        }
    ],
    [
        {
            "score": 0.35336410999298096,
            "start": 419,
            "end": 420,
            "answer": "4"
        },
        {
            "score": 0.056826114654541016,
            "start": 1522,
            "end": 1525,
            "answer": "d+1"
        },
        {
            "score": 0.05219800025224686,
            "start": 1522,
            "end": 1621,
            "answer": "d+1 in the new representation.  Since all pairs of code words have Hamming distance of at least d+1"
        },
        {
            "score": 0.045072536915540695,
            "start": 419,
            "end": 446,
            "answer": "4.  A Hamming distance of 4"
        },
        {
            "score": 0.03821003809571266,
            "start": 1618,
            "end": 1621,
            "answer": "d+1"
        }
    ],
    [
        {
            "score": 0.01298367977142334,
            "start": 1205,
            "end": 1215,
            "answer": "assemblers"
        },
        {
            "score": 0.003701145062223077,
            "start": 1205,
            "end": 1233,
            "answer": "assemblers and assembly code"
        },
        {
            "score": 0.002574863377958536,
            "start": 1205,
            "end": 1215,
            "answer": "assemblers"
        },
        {
            "score": 0.0021398901008069515,
            "start": 3658,
            "end": 3688,
            "answer": "explain how an assembler works"
        },
        {
            "score": 0.0016096893232315779,
            "start": 1204,
            "end": 1215,
            "answer": "{assemblers"
        }
    ],
    [
        {
            "score": 0.0006947291549295187,
            "start": 421,
            "end": 463,
            "answer": "the same approach can  be used in software"
        },
        {
            "score": 0.0006216421606950462,
            "start": 243,
            "end": 463,
            "answer": "abstraction for logic design.  We follow this approach to design an adder known as a ripple-carry adder, then discuss some of the  implications of the approach and highlight how the same approach can  be used in software"
        },
        {
            "score": 0.0004999279626645148,
            "start": 425,
            "end": 463,
            "answer": "same approach can  be used in software"
        },
        {
            "score": 0.00042629725066944957,
            "start": 232,
            "end": 463,
            "answer": "important  abstraction for logic design.  We follow this approach to design an adder known as a ripple-carry adder, then discuss some of the  implications of the approach and highlight how the same approach can  be used in software"
        },
        {
            "score": 0.000370762892998755,
            "start": 243,
            "end": 271,
            "answer": "abstraction for logic design"
        }
    ],
    [
        {
            "score": 0.001608683611266315,
            "start": 1408,
            "end": 1473,
            "answer": "simplicity of the approach makes the tradeoff an interesting one."
        },
        {
            "score": 0.0006629767012782395,
            "start": 1289,
            "end": 1473,
            "answer": "less efficient than designs that are optimized for their specific purpose (such as adding two 17-bit numbers), but the simplicity of the approach makes the tradeoff an interesting one."
        },
        {
            "score": 0.0006281604873947799,
            "start": 1404,
            "end": 1473,
            "answer": "the simplicity of the approach makes the tradeoff an interesting one."
        },
        {
            "score": 0.00043544944492168725,
            "start": 1102,
            "end": 1240,
            "answer": "we can mimic our approach as humans and build adders of any size, just as we expect that a human could add two binary numbers of any size."
        },
        {
            "score": 0.00043527816887944937,
            "start": 1102,
            "end": 1473,
            "answer": "we can mimic our approach as humans and build adders of any size, just as we expect that a human could add two binary numbers of any size.  The resulting designs are, of course, slightly less efficient than designs that are optimized for their specific purpose (such as adding two 17-bit numbers), but the simplicity of the approach makes the tradeoff an interesting one."
        }
    ],
    [
        {
            "score": 0.4309085011482239,
            "start": 2048,
            "end": 2102,
            "answer": "adding three inputs bits and producing two output bits"
        },
        {
            "score": 0.36800116300582886,
            "start": 2048,
            "end": 2102,
            "answer": "adding three inputs bits and producing two output bits"
        },
        {
            "score": 0.1320771425962448,
            "start": 2044,
            "end": 2102,
            "answer": "for adding three inputs bits and producing two output bits"
        },
        {
            "score": 0.04520757868885994,
            "start": 2048,
            "end": 2259,
            "answer": "adding three inputs bits and producing two output bits is called a { full adder}.  You may  also encounter the term { half adder}, which adds only two input bits.  To form an {N-bit} adder, we integrate N copies"
        },
        {
            "score": 0.040861304849386215,
            "start": 2048,
            "end": 2259,
            "answer": "adding three inputs bits and producing two output bits is called a { full adder}.  You may  also encounter the term { half adder}, which adds only two input bits.  To form an {N-bit} adder, we integrate N copies"
        }
    ],
    [
        {
            "score": 0.1050853356719017,
            "start": 2971,
            "end": 2978,
            "answer": "A and B"
        },
        {
            "score": 0.08258488029241562,
            "start": 2971,
            "end": 3000,
            "answer": "A and B inputs to the outputs"
        },
        {
            "score": 0.06164807826280594,
            "start": 2971,
            "end": 3056,
            "answer": "A and B inputs to the outputs is not as important as the delay from C_ to the outputs"
        },
        {
            "score": 0.05058782920241356,
            "start": 2971,
            "end": 2985,
            "answer": "A and B inputs"
        },
        {
            "score": 0.021573277190327644,
            "start": 2967,
            "end": 2978,
            "answer": "the A and B"
        }
    ],
    [
        {
            "score": 0.1060522273182869,
            "start": 475,
            "end": 611,
            "answer": "any time  you see a symbol of the shape shown to the right, it is an adder} (or  sometimes a device that can add and do other operations"
        },
        {
            "score": 0.07694011181592941,
            "start": 475,
            "end": 533,
            "answer": "any time  you see a symbol of the shape shown to the right"
        },
        {
            "score": 0.03234201669692993,
            "start": 2387,
            "end": 2394,
            "answer": "{N-bit}"
        },
        {
            "score": 0.028666505590081215,
            "start": 1720,
            "end": 1762,
            "answer": "connecting two copies of the {N-bit} adder"
        },
        {
            "score": 0.028438452631235123,
            "start": 1713,
            "end": 1762,
            "answer": "simply connecting two copies of the {N-bit} adder"
        }
    ],
    [
        {
            "score": 0.12553012371063232,
            "start": 2869,
            "end": 2903,
            "answer": "bistable states used to hold a bit"
        },
        {
            "score": 0.06349693238735199,
            "start": 2865,
            "end": 2903,
            "answer": "the bistable states used to hold a bit"
        },
        {
            "score": 0.02502616122364998,
            "start": 2856,
            "end": 2903,
            "answer": "terms of the bistable states used to hold a bit"
        },
        {
            "score": 0.01343144103884697,
            "start": 2852,
            "end": 2903,
            "answer": "in  terms of the bistable states used to hold a bit"
        },
        {
            "score": 0.013142979703843594,
            "start": 2839,
            "end": 2903,
            "answer": "particularly in  terms of the bistable states used to hold a bit"
        }
    ],
    [
        {
            "score": 0.047156572341918945,
            "start": 2,
            "end": 231,
            "answer": "This set of notes introduces registers, an abstraction used for  storage of groups of bits in digital systems.  We introduce some terminology used to describe aspects of register design and illustrate the idea of a shift register"
        },
        {
            "score": 0.044744063168764114,
            "start": 2,
            "end": 311,
            "answer": "This set of notes introduces registers, an abstraction used for  storage of groups of bits in digital systems.  We introduce some terminology used to describe aspects of register design and illustrate the idea of a shift register.  The registers shown here are important abstractions for digital system design"
        },
        {
            "score": 0.03819037601351738,
            "start": 2,
            "end": 40,
            "answer": "This set of notes introduces registers"
        },
        {
            "score": 0.03753870725631714,
            "start": 2,
            "end": 19,
            "answer": "This set of notes"
        },
        {
            "score": 0.017061086371541023,
            "start": 263,
            "end": 311,
            "answer": "important abstractions for digital system design"
        }
    ],
    [
        {
            "score": 0.1219438686966896,
            "start": 1801,
            "end": 1840,
            "answer": "as a bit slice for a multi-bit register"
        },
        {
            "score": 0.09878155589103699,
            "start": 1804,
            "end": 1840,
            "answer": "a bit slice for a multi-bit register"
        },
        {
            "score": 0.06374406069517136,
            "start": 1806,
            "end": 1840,
            "answer": "bit slice for a multi-bit register"
        },
        {
            "score": 0.021561479195952415,
            "start": 1801,
            "end": 1815,
            "answer": "as a bit slice"
        },
        {
            "score": 0.021089419722557068,
            "start": 1822,
            "end": 1840,
            "answer": "multi-bit register"
        }
    ],
    [
        {
            "score": 0.4943926930427551,
            "start": 241,
            "end": 265,
            "answer": "a series of D flip-flops"
        },
        {
            "score": 0.22395923733711243,
            "start": 3451,
            "end": 3464,
            "answer": "bidirectional"
        },
        {
            "score": 0.151515394449234,
            "start": 243,
            "end": 265,
            "answer": "series of D flip-flops"
        },
        {
            "score": 0.07281729578971863,
            "start": 2600,
            "end": 2619,
            "answer": "shifts continuously"
        },
        {
            "score": 0.07226558029651642,
            "start": 3443,
            "end": 3464,
            "answer": "{4-bit} bidirectional"
        }
    ],
    [
        {
            "score": 0.26363736391067505,
            "start": 360,
            "end": 419,
            "answer": "allow for selection of the simplest possible implementation"
        },
        {
            "score": 0.20937436819076538,
            "start": 370,
            "end": 419,
            "answer": "selection of the simplest possible implementation"
        },
        {
            "score": 0.16061241924762726,
            "start": 357,
            "end": 419,
            "answer": "to allow for selection of the simplest possible implementation"
        },
        {
            "score": 0.09762263298034668,
            "start": 351,
            "end": 419,
            "answer": "so as to allow for selection of the simplest possible implementation"
        },
        {
            "score": 0.03189579024910927,
            "start": 387,
            "end": 419,
            "answer": "simplest possible implementation"
        }
    ],
    [
        {
            "score": 0.37630122900009155,
            "start": 1920,
            "end": 1954,
            "answer": "we do not prove the principle here"
        },
        {
            "score": 0.2800707519054413,
            "start": 1920,
            "end": 1949,
            "answer": "we do not prove the principle"
        },
        {
            "score": 0.1359512060880661,
            "start": 1000,
            "end": 1089,
            "answer": "any logic statement (an expression or an equation) is related to a second logic statement"
        },
        {
            "score": 0.06420363485813141,
            "start": 1920,
            "end": 1956,
            "answer": "we do not prove the principle here)."
        },
        {
            "score": 0.0421409085392952,
            "start": 1054,
            "end": 1089,
            "answer": "related to a second logic statement"
        }
    ],
    [
        {
            "score": 0.14816886186599731,
            "start": 1368,
            "end": 1474,
            "answer": "allows you to choose from among several possible logic functions, all of which produce the desired results"
        },
        {
            "score": 0.13244785368442535,
            "start": 1368,
            "end": 1432,
            "answer": "allows you to choose from among several possible logic functions"
        },
        {
            "score": 0.052462924271821976,
            "start": 1340,
            "end": 1474,
            "answer": "Using ``don't care'' values allows you to choose from among several possible logic functions, all of which produce the desired results"
        },
        {
            "score": 0.04689650610089302,
            "start": 1340,
            "end": 1432,
            "answer": "Using ``don't care'' values allows you to choose from among several possible logic functions"
        },
        {
            "score": 0.03635186702013016,
            "start": 1368,
            "end": 1556,
            "answer": "allows you to choose from among several possible logic functions, all of which produce the desired results (as well as some combination of 0s and 1s in place of the ``don't care'' values)."
        }
    ],
    [
        {
            "score": 0.3306514322757721,
            "start": 1725,
            "end": 1771,
            "answer": "more convenient in terms of creating the logic"
        },
        {
            "score": 0.17005744576454163,
            "start": 1725,
            "end": 1740,
            "answer": "more convenient"
        },
        {
            "score": 0.11496211588382721,
            "start": 4727,
            "end": 4790,
            "answer": "make  choices and to add the new decisions to the specification"
        },
        {
            "score": 0.11202783137559891,
            "start": 4748,
            "end": 4790,
            "answer": "add the new decisions to the specification"
        },
        {
            "score": 0.09667057543992996,
            "start": 1235,
            "end": 1275,
            "answer": "1  when pressed and a 0 when not pressed"
        }
    ],
    [
        {
            "score": 0.20852972567081451,
            "start": 236,
            "end": 249,
            "answer": "later classes"
        },
        {
            "score": 0.05781199410557747,
            "start": 191,
            "end": 249,
            "answer": "the field and are sometimes the subjects of  later classes"
        },
        {
            "score": 0.044916003942489624,
            "start": 219,
            "end": 249,
            "answer": "the subjects of  later classes"
        },
        {
            "score": 0.031173616647720337,
            "start": 223,
            "end": 249,
            "answer": "subjects of  later classes"
        },
        {
            "score": 0.027913302183151245,
            "start": 235,
            "end": 249,
            "answer": " later classes"
        }
    ],
    [
        {
            "score": 0.04257699474692345,
            "start": 1353,
            "end": 1460,
            "answer": "``best'' way to express a Boolean function and some techniques used historically to evaluate such decisions"
        },
        {
            "score": 0.025802642107009888,
            "start": 1405,
            "end": 1460,
            "answer": "techniques used historically to evaluate such decisions"
        },
        {
            "score": 0.017861710861325264,
            "start": 1400,
            "end": 1460,
            "answer": "some techniques used historically to evaluate such decisions"
        },
        {
            "score": 0.012604046612977982,
            "start": 1353,
            "end": 1415,
            "answer": "``best'' way to express a Boolean function and some techniques"
        },
        {
            "score": 0.011436273343861103,
            "start": 1353,
            "end": 1361,
            "answer": "``best''"
        }
    ],
    [
        {
            "score": 0.15368108451366425,
            "start": 3919,
            "end": 4034,
            "answer": "one that is believed to yield fairly good solutions to a problem, but does not necessarily find an optimal solution"
        },
        {
            "score": 0.08009859919548035,
            "start": 3286,
            "end": 3358,
            "answer": "if a chip finishes its work, the chip can turn itself off, saving energy"
        },
        {
            "score": 0.06140226125717163,
            "start": 3267,
            "end": 3358,
            "answer": "sometimes related: if a chip finishes its work, the chip can turn itself off, saving energy"
        },
        {
            "score": 0.05979546159505844,
            "start": 3277,
            "end": 3358,
            "answer": "related: if a chip finishes its work, the chip can turn itself off, saving energy"
        },
        {
            "score": 0.05224974825978279,
            "start": 3919,
            "end": 3983,
            "answer": "one that is believed to yield fairly good solutions to a problem"
        }
    ],
    [
        {
            "score": 0.36933979392051697,
            "start": 1321,
            "end": 1423,
            "answer": "a product (AND  function) of N literals in which each variable or its complement  appears exactly once"
        },
        {
            "score": 0.31782469153404236,
            "start": 1321,
            "end": 1360,
            "answer": "a product (AND  function) of N literals"
        },
        {
            "score": 0.2948997914791107,
            "start": 1321,
            "end": 1423,
            "answer": "a product (AND  function) of N literals in which each variable or its complement  appears exactly once"
        },
        {
            "score": 0.2521895468235016,
            "start": 1321,
            "end": 1360,
            "answer": "a product (AND  function) of N literals"
        },
        {
            "score": 0.2443391978740692,
            "start": 3757,
            "end": 3774,
            "answer": "an implicant of F"
        }
    ],
    [
        {
            "score": 0.1563311666250229,
            "start": 280,
            "end": 360,
            "answer": "The twist makes the use of  { Karnaugh maps} to simplify expressions much easier"
        },
        {
            "score": 0.11586225777864456,
            "start": 4270,
            "end": 4279,
            "answer": "arbitrary"
        },
        {
            "score": 0.07122120261192322,
            "start": 10813,
            "end": 10843,
            "answer": "their use is a little trickier"
        },
        {
            "score": 0.05694674327969551,
            "start": 6251,
            "end": 6273,
            "answer": "The use of a Gray code"
        },
        {
            "score": 0.04961932823061943,
            "start": 284,
            "end": 360,
            "answer": "twist makes the use of  { Karnaugh maps} to simplify expressions much easier"
        }
    ],
    [
        {
            "score": 0.3091115653514862,
            "start": 1809,
            "end": 1824,
            "answer": "sum of minterms"
        },
        {
            "score": 0.30009785294532776,
            "start": 1805,
            "end": 1824,
            "answer": "the sum of minterms"
        },
        {
            "score": 0.0552322156727314,
            "start": 1816,
            "end": 1824,
            "answer": "minterms"
        },
        {
            "score": 0.03399069607257843,
            "start": 1722,
            "end": 1824,
            "answer": "The { canonical sum} of a function (sometimes called the { canonical SOP form}) is the sum of minterms"
        },
        {
            "score": 0.028067681938409805,
            "start": 1728,
            "end": 1824,
            "answer": "canonical sum} of a function (sometimes called the { canonical SOP form}) is the sum of minterms"
        }
    ],
    [
        {
            "score": 0.4005010724067688,
            "start": 1466,
            "end": 1519,
            "answer": "makes it simple to map our expression into CMOS gates"
        },
        {
            "score": 0.22552643716335297,
            "start": 118,
            "end": 190,
            "answer": "the number of functions through which an input passes to reach an output"
        },
        {
            "score": 0.16464325785636902,
            "start": 122,
            "end": 190,
            "answer": "number of functions through which an input passes to reach an output"
        },
        {
            "score": 0.14871981739997864,
            "start": 87,
            "end": 190,
            "answer": "The two levels refer simply to the number of functions through which an input passes to reach an output"
        },
        {
            "score": 0.08748222887516022,
            "start": 1475,
            "end": 1519,
            "answer": "simple to map our expression into CMOS gates"
        }
    ],
    [
        {
            "score": 0.08044654875993729,
            "start": 9923,
            "end": 9948,
            "answer": "many hours of computation"
        },
        {
            "score": 0.07011513411998749,
            "start": 9902,
            "end": 9948,
            "answer": "many computers using many hours of computation"
        },
        {
            "score": 0.03752464801073074,
            "start": 9917,
            "end": 9948,
            "answer": "using many hours of computation"
        },
        {
            "score": 0.022880075499415398,
            "start": 9894,
            "end": 9948,
            "answer": "done by many computers using many hours of computation"
        },
        {
            "score": 0.019479798153042793,
            "start": 9880,
            "end": 9948,
            "answer": "was of course done by many computers using many hours of computation"
        }
    ],
    [
        {
            "score": 0.576785147190094,
            "start": 63,
            "end": 75,
            "answer": "storing bits"
        },
        {
            "score": 0.34648749232292175,
            "start": 59,
            "end": 75,
            "answer": "for storing bits"
        },
        {
            "score": 0.007032991852611303,
            "start": 63,
            "end": 76,
            "answer": "storing bits,"
        },
        {
            "score": 0.004224872682243586,
            "start": 59,
            "end": 76,
            "answer": "for storing bits,"
        },
        {
            "score": 0.002635454060509801,
            "start": 42,
            "end": 75,
            "answer": "logic components for storing bits"
        }
    ],
    [
        {
            "score": 0.2308390736579895,
            "start": 5417,
            "end": 5420,
            "answer": "D=1"
        },
        {
            "score": 0.175763338804245,
            "start": 4011,
            "end": 4021,
            "answer": "active low"
        },
        {
            "score": 0.09027102589607239,
            "start": 5417,
            "end": 5420,
            "answer": "D=1"
        },
        {
            "score": 0.0347956120967865,
            "start": 3866,
            "end": 3896,
            "answer": "add an input to the other gate"
        },
        {
            "score": 0.022395426407456398,
            "start": 4011,
            "end": 4049,
            "answer": "active low.  We extend the truth table"
        }
    ],
    [
        {
            "score": 0.06578298658132553,
            "start": 5007,
            "end": 5014,
            "answer": "one bit"
        },
        {
            "score": 0.029340878129005432,
            "start": 5175,
            "end": 5256,
            "answer": "their behavior depends on the bits currently stored in the latches and flip-flops"
        },
        {
            "score": 0.02932600863277912,
            "start": 4997,
            "end": 5014,
            "answer": "can store one bit"
        },
        {
            "score": 0.029102422297000885,
            "start": 4952,
            "end": 5014,
            "answer": "Each cycle in a sequential feedback  circuit can store one bit"
        },
        {
            "score": 0.02114577777683735,
            "start": 5140,
            "end": 5256,
            "answer": "Such designs are still sequential: their behavior depends on the bits currently stored in the latches and flip-flops"
        }
    ],
    [
        {
            "score": 0.3465447723865509,
            "start": 2552,
            "end": 2560,
            "answer": "Static-0"
        },
        {
            "score": 0.25771382451057434,
            "start": 2552,
            "end": 2561,
            "answer": "Static-0}"
        },
        {
            "score": 0.13430951535701752,
            "start": 2551,
            "end": 2560,
            "answer": "{Static-0"
        },
        {
            "score": 0.09988153725862503,
            "start": 2551,
            "end": 2561,
            "answer": "{Static-0}"
        },
        {
            "score": 0.09505578130483627,
            "start": 2552,
            "end": 2569,
            "answer": "Static-0} hazards"
        }
    ],
    [
        {
            "score": 0.3991061747074127,
            "start": 2898,
            "end": 2908,
            "answer": "clock skew"
        },
        {
            "score": 0.22762203216552734,
            "start": 2898,
            "end": 2908,
            "answer": "clock skew"
        },
        {
            "score": 0.034101828932762146,
            "start": 1,
            "end": 18,
            "answer": "Essential Hazards"
        },
        {
            "score": 0.029342610388994217,
            "start": 1,
            "end": 41,
            "answer": "Essential Hazards*}  { Essential hazards"
        },
        {
            "score": 0.02412409335374832,
            "start": 2820,
            "end": 2908,
            "answer": "clocked synchronous sequential circuits, all essential hazards are related to clock skew"
        }
    ],
    [
        {
            "score": 0.34786033630371094,
            "start": 2069,
            "end": 2191,
            "answer": "a difference between the final state when flipping a bit once and the final state when flipping a bit thrice in succession"
        },
        {
            "score": 0.23628970980644226,
            "start": 2071,
            "end": 2191,
            "answer": "difference between the final state when flipping a bit once and the final state when flipping a bit thrice in succession"
        },
        {
            "score": 0.04871436581015587,
            "start": 2069,
            "end": 2130,
            "answer": "a difference between the final state when flipping a bit once"
        },
        {
            "score": 0.043874096125364304,
            "start": 674,
            "end": 684,
            "answer": "clock skew"
        },
        {
            "score": 0.0330900177359581,
            "start": 2071,
            "end": 2130,
            "answer": "difference between the final state when flipping a bit once"
        }
    ],
    [
        {
            "score": 0.017917459830641747,
            "start": 630,
            "end": 648,
            "answer": "bit-sliced designs"
        },
        {
            "score": 0.015031004324555397,
            "start": 64,
            "end": 214,
            "answer": "we illustrate the use of abstraction to simplify problems, then introduce a component called a multiplexer that allows selection among multiple inputs"
        },
        {
            "score": 0.011346365325152874,
            "start": 128,
            "end": 214,
            "answer": "introduce a component called a multiplexer that allows selection among multiple inputs"
        },
        {
            "score": 0.010452278889715672,
            "start": 67,
            "end": 214,
            "answer": "illustrate the use of abstraction to simplify problems, then introduce a component called a multiplexer that allows selection among multiple inputs"
        },
        {
            "score": 0.01021391712129116,
            "start": 64,
            "end": 648,
            "answer": "we illustrate the use of abstraction to simplify problems, then introduce a component called a multiplexer that allows selection among multiple inputs.  We begin by showing how two specific  examples---integer subtraction and identification of letters in ASCII---can be implemented using logic functions that we have already developed.  We also introduce a conceptual technique for breaking functions into smaller pieces, which allows us to solve several simpler problems and then to compose a full solution from  these partial solutions.  Together with the idea of bit-sliced designs"
        }
    ],
    [
        {
            "score": 0.038735900074243546,
            "start": 2856,
            "end": 2864,
            "answer": "overflow"
        },
        {
            "score": 0.03833925724029541,
            "start": 2856,
            "end": 2880,
            "answer": "overflow for subtraction"
        },
        {
            "score": 0.03512320667505264,
            "start": 2852,
            "end": 2864,
            "answer": "an  overflow"
        },
        {
            "score": 0.03476355969905853,
            "start": 2852,
            "end": 2880,
            "answer": "an  overflow for subtraction"
        },
        {
            "score": 0.007832152768969536,
            "start": 2855,
            "end": 2864,
            "answer": " overflow"
        }
    ],
    [
        {
            "score": 0.10343001782894135,
            "start": 280,
            "end": 313,
            "answer": "C represents an upper-case letter"
        },
        {
            "score": 0.09018205106258392,
            "start": 271,
            "end": 313,
            "answer": "whenever C represents an upper-case letter"
        },
        {
            "score": 0.038767557591199875,
            "start": 241,
            "end": 313,
            "answer": "The function U should equal 1 whenever C represents an upper-case letter"
        },
        {
            "score": 0.027795104309916496,
            "start": 263,
            "end": 313,
            "answer": "equal 1 whenever C represents an upper-case letter"
        },
        {
            "score": 0.025075485929846764,
            "start": 296,
            "end": 313,
            "answer": "upper-case letter"
        }
    ],
    [
        {
            "score": 0.4511180520057678,
            "start": 1212,
            "end": 1219,
            "answer": "trivial"
        },
        {
            "score": 0.07587622851133347,
            "start": 1204,
            "end": 1219,
            "answer": "becomes trivial"
        },
        {
            "score": 0.06512425094842911,
            "start": 1169,
            "end": 1219,
            "answer": "the design of a lower-case checker becomes trivial"
        },
        {
            "score": 0.035139355808496475,
            "start": 1103,
            "end": 1219,
            "answer": "Finally, if we have used a design based on comparators or adders, the design of a lower-case checker becomes trivial"
        },
        {
            "score": 0.024318838492035866,
            "start": 1173,
            "end": 1219,
            "answer": "design of a lower-case checker becomes trivial"
        }
    ],
    [
        {
            "score": 0.11429336667060852,
            "start": 607,
            "end": 669,
            "answer": "The simplest form of the multiplexer is the 2-to-1 multiplexer"
        },
        {
            "score": 0.05787060782313347,
            "start": 607,
            "end": 689,
            "answer": "The simplest form of the multiplexer is the 2-to-1 multiplexer shown to  the right"
        },
        {
            "score": 0.05446099489927292,
            "start": 651,
            "end": 669,
            "answer": "2-to-1 multiplexer"
        },
        {
            "score": 0.042838796973228455,
            "start": 607,
            "end": 657,
            "answer": "The simplest form of the multiplexer is the 2-to-1"
        },
        {
            "score": 0.03797994554042816,
            "start": 647,
            "end": 669,
            "answer": "the 2-to-1 multiplexer"
        }
    ],
    [
        {
            "score": 0.0002802191593218595,
            "start": 10,
            "end": 294,
            "answer": "Bit-Sliced Comparison}  This set of notes develops comparators for unsigned and 2's complement  numbers using the bit-sliced approach that we introduced in Notes Set 2.3.   We then use algebraic manipulation and variation of the internal  representation to illustrate design tradeoffs"
        },
        {
            "score": 0.00023421997320838273,
            "start": 61,
            "end": 294,
            "answer": "comparators for unsigned and 2's complement  numbers using the bit-sliced approach that we introduced in Notes Set 2.3.   We then use algebraic manipulation and variation of the internal  representation to illustrate design tradeoffs"
        },
        {
            "score": 0.000226046031457372,
            "start": 10,
            "end": 72,
            "answer": "Bit-Sliced Comparison}  This set of notes develops comparators"
        },
        {
            "score": 0.0001889396080514416,
            "start": 61,
            "end": 72,
            "answer": "comparators"
        },
        {
            "score": 0.00016016923473216593,
            "start": 10,
            "end": 31,
            "answer": "Bit-Sliced Comparison"
        }
    ],
    [
        {
            "score": 0.17989656329154968,
            "start": 444,
            "end": 520,
            "answer": "if we find a difference in that bit, we are done, saving ourselves some time"
        },
        {
            "score": 0.11720374971628189,
            "start": 494,
            "end": 520,
            "answer": "saving ourselves some time"
        },
        {
            "score": 0.035394955426454544,
            "start": 444,
            "end": 492,
            "answer": "if we find a difference in that bit, we are done"
        },
        {
            "score": 0.026025913655757904,
            "start": 481,
            "end": 520,
            "answer": "we are done, saving ourselves some time"
        },
        {
            "score": 0.015086976811289787,
            "start": 444,
            "end": 479,
            "answer": "if we find a difference in that bit"
        }
    ],
    [
        {
            "score": 0.07430684566497803,
            "start": 843,
            "end": 902,
            "answer": "pass one of three possible answers to the logic for bit M+1"
        },
        {
            "score": 0.029147479683160782,
            "start": 755,
            "end": 902,
            "answer": "accept  three possible answers from the bit slice logic for bit M-1 and must be able to pass one of three possible answers to the logic for bit M+1"
        },
        {
            "score": 0.021014798432588577,
            "start": 848,
            "end": 902,
            "answer": "one of three possible answers to the logic for bit M+1"
        },
        {
            "score": 0.019348833709955215,
            "start": 645,
            "end": 902,
            "answer": "pass along the result from the less significant bits.  Thus our bit slice logic for bit M needs to be able to accept  three possible answers from the bit slice logic for bit M-1 and must be able to pass one of three possible answers to the logic for bit M+1"
        },
        {
            "score": 0.015303975902497768,
            "start": 843,
            "end": 877,
            "answer": "pass one of three possible answers"
        }
    ],
    [
        {
            "score": 0.01711115427315235,
            "start": 4189,
            "end": 4197,
            "answer": "a reader"
        },
        {
            "score": 0.0074802180752158165,
            "start": 4191,
            "end": 4197,
            "answer": "reader"
        },
        {
            "score": 0.007154456805437803,
            "start": 4369,
            "end": 4378,
            "answer": "output 01"
        },
        {
            "score": 0.00591740757226944,
            "start": 3974,
            "end": 4197,
            "answer": "Z_1Z_0=xx.  But these two rows overlap in the input space!  In other words, some input patterns, such as ABC_1C_0=0111, match both of our suggested new rows.  Which output should take precedence? The answer is that a reader"
        },
        {
            "score": 0.004440955352038145,
            "start": 4720,
            "end": 4734,
            "answer": "whatever order"
        }
    ],
    [
        {
            "score": 0.0003564188373275101,
            "start": 1622,
            "end": 1632,
            "answer": "four gates"
        },
        {
            "score": 0.0002605716581456363,
            "start": 1622,
            "end": 1730,
            "answer": "four gates (maximum) instead of three.  Yet the path from C_1 and C_0 to the outputs is still only two gates"
        },
        {
            "score": 0.00019060213526245207,
            "start": 1622,
            "end": 1659,
            "answer": "four gates (maximum) instead of three"
        },
        {
            "score": 0.00012508276267908514,
            "start": 1721,
            "end": 1730,
            "answer": "two gates"
        },
        {
            "score": 8.850626181811094e-05,
            "start": 1654,
            "end": 1730,
            "answer": "three.  Yet the path from C_1 and C_0 to the outputs is still only two gates"
        }
    ],
    [
        {
            "score": 0.12526875734329224,
            "start": 2288,
            "end": 2314,
            "answer": "two A=B cases are reversed"
        },
        {
            "score": 0.09545297920703888,
            "start": 2284,
            "end": 2314,
            "answer": "the two A=B cases are reversed"
        },
        {
            "score": 0.05540631711483002,
            "start": 2292,
            "end": 2314,
            "answer": "A=B cases are reversed"
        },
        {
            "score": 0.00997541006654501,
            "start": 2288,
            "end": 2667,
            "answer": "two A=B cases are reversed.  If we swap A_s and B_s, the function is identical.  We can simply use another bit slice but swap these two inputs.  Implementation of an {N-bit} 2's complement comparator based on our bit slice comparator is shown below.  The blue circle highlights the only change from the {N-bit} unsigned comparator, which is to swap the two inputs on the sign bit"
        },
        {
            "score": 0.009691855870187283,
            "start": 2288,
            "end": 2315,
            "answer": "two A=B cases are reversed."
        }
    ],
    [
        {
            "score": 0.022732462733983994,
            "start": 691,
            "end": 810,
            "answer": "C_0=1 whenever A=B.    Once we have found the numbers to be different in some bit, the end result can never be equality"
        },
        {
            "score": 0.017558563500642776,
            "start": 714,
            "end": 810,
            "answer": "Once we have found the numbers to be different in some bit, the end result can never be equality"
        },
        {
            "score": 0.014538883231580257,
            "start": 774,
            "end": 810,
            "answer": "the end result can never be equality"
        },
        {
            "score": 0.011276505887508392,
            "start": 691,
            "end": 709,
            "answer": "C_0=1 whenever A=B"
        },
        {
            "score": 0.004610407631844282,
            "start": 691,
            "end": 710,
            "answer": "C_0=1 whenever A=B."
        }
    ],
    [
        {
            "score": 0.011686267331242561,
            "start": 1,
            "end": 17,
            "answer": "Logic Operations"
        },
        {
            "score": 0.009247944690287113,
            "start": 158,
            "end": 592,
            "answer": "completeness    implications of completeness: enable abstraction, and evaluate      future possible implementations of devices quickly: logically complete      or not?    examples    generalizing to operations on sets of bits    This set of notes briefly describes a generalization to truth tables, then introduces Boolean logic operations as well as  notational conventions and tools that we use to express general functions on bits."
        },
        {
            "score": 0.008610730059444904,
            "start": 387,
            "end": 592,
            "answer": "This set of notes briefly describes a generalization to truth tables, then introduces Boolean logic operations as well as  notational conventions and tools that we use to express general functions on bits."
        },
        {
            "score": 0.008610730059444904,
            "start": 387,
            "end": 823,
            "answer": "This set of notes briefly describes a generalization to truth tables, then introduces Boolean logic operations as well as  notational conventions and tools that we use to express general functions on bits.  We illustrate how logic operations enable  us to express functions such as overflow conditions concisely, then show by construction that a small number of logic operations suffices to describe any operation on any number of bits."
        },
        {
            "score": 0.008610498160123825,
            "start": 387,
            "end": 881,
            "answer": "This set of notes briefly describes a generalization to truth tables, then introduces Boolean logic operations as well as  notational conventions and tools that we use to express general functions on bits.  We illustrate how logic operations enable  us to express functions such as overflow conditions concisely, then show by construction that a small number of logic operations suffices to describe any operation on any number of bits.   We close by discussing a few implications and examples."
        }
    ],
    [
        {
            "score": 0.276292622089386,
            "start": 193,
            "end": 233,
            "answer": "reducing the amount of writing necessary"
        },
        {
            "score": 0.17634376883506775,
            "start": 193,
            "end": 223,
            "answer": "reducing the amount of writing"
        },
        {
            "score": 0.15954652428627014,
            "start": 193,
            "end": 257,
            "answer": "reducing the amount of writing necessary when using truth tables"
        },
        {
            "score": 0.027905084192752838,
            "start": 181,
            "end": 233,
            "answer": "the goal of reducing the amount of writing necessary"
        },
        {
            "score": 0.02043883502483368,
            "start": 185,
            "end": 233,
            "answer": "goal of reducing the amount of writing necessary"
        }
    ],
    [
        {
            "score": 0.150553897023201,
            "start": 6410,
            "end": 6421,
            "answer": "associative"
        },
        {
            "score": 0.12121239304542542,
            "start": 5477,
            "end": 5486,
            "answer": "exclusive"
        },
        {
            "score": 0.08108258992433548,
            "start": 4146,
            "end": 4173,
            "answer": "0 if all input values are 0"
        },
        {
            "score": 0.07060474157333374,
            "start": 5477,
            "end": 5489,
            "answer": "exclusive OR"
        },
        {
            "score": 0.03122306428849697,
            "start": 4146,
            "end": 4173,
            "answer": "0 if all input values are 0"
        }
    ],
    [
        {
            "score": 0.016260141506791115,
            "start": 1987,
            "end": 2034,
            "answer": "the two least significant bits generate a carry"
        },
        {
            "score": 0.013180415146052837,
            "start": 1935,
            "end": 2034,
            "answer": "The last term represents the overflow case in which the two least significant bits generate a carry"
        },
        {
            "score": 0.010932570323348045,
            "start": 2698,
            "end": 2872,
            "answer": "{eqnarray*} A_{N-1} B_{N-1} {S_{N-1}}+ {A_{N-1}} {B_{N-1}} S_{N-1} {eqnarray*}  The overflow condition does of course depend on all of the bits in the two numbers being added"
        },
        {
            "score": 0.0062815165147185326,
            "start": 1991,
            "end": 2034,
            "answer": "two least significant bits generate a carry"
        },
        {
            "score": 0.0059814415872097015,
            "start": 2698,
            "end": 2709,
            "answer": "{eqnarray*}"
        }
    ],
    [
        {
            "score": 0.11975348740816116,
            "start": 563,
            "end": 769,
            "answer": "The theorem below captures this idea, called { logical completeness}. In this case, we claim that the set of functions {AND, OR, NOT} is sufficient to express any operation on any finite number of variables"
        },
        {
            "score": 0.0606549009680748,
            "start": 458,
            "end": 769,
            "answer": "The functions AND, OR, and NOT are sufficient, even if we only allow two input operands for AND and OR!  The theorem below captures this idea, called { logical completeness}. In this case, we claim that the set of functions {AND, OR, NOT} is sufficient to express any operation on any finite number of variables"
        },
        {
            "score": 0.026644032448530197,
            "start": 563,
            "end": 574,
            "answer": "The theorem"
        },
        {
            "score": 0.026343224570155144,
            "start": 661,
            "end": 769,
            "answer": "the set of functions {AND, OR, NOT} is sufficient to express any operation on any finite number of variables"
        },
        {
            "score": 0.022733816877007484,
            "start": 458,
            "end": 503,
            "answer": "The functions AND, OR, and NOT are sufficient"
        }
    ],
    [
        {
            "score": 0.6381120085716248,
            "start": 40,
            "end": 114,
            "answer": "If logical completeness doesn't really help us to engineer logic functions"
        },
        {
            "score": 0.06410176306962967,
            "start": 43,
            "end": 114,
            "answer": "logical completeness doesn't really help us to engineer logic functions"
        },
        {
            "score": 0.06128902733325958,
            "start": 1601,
            "end": 1650,
            "answer": "both the set  and the set  are logically complete"
        },
        {
            "score": 0.06010468304157257,
            "start": 40,
            "end": 142,
            "answer": "If logical completeness doesn't really help us to engineer logic functions, why is the idea important?"
        },
        {
            "score": 0.02308158576488495,
            "start": 40,
            "end": 115,
            "answer": "If logical completeness doesn't really help us to engineer logic functions,"
        }
    ],
    [
        {
            "score": 0.3894749581813812,
            "start": 3209,
            "end": 3212,
            "answer": "XOR"
        },
        {
            "score": 0.07552069425582886,
            "start": 1591,
            "end": 1658,
            "answer": "A=A_7A_6A_5A_4A_3A_2A_1A_0, we want to compare it with the value -1"
        },
        {
            "score": 0.06499477475881577,
            "start": 1656,
            "end": 1658,
            "answer": "-1"
        },
        {
            "score": 0.05774162709712982,
            "start": 3209,
            "end": 3242,
            "answer": "XOR, to operate on bits of groups"
        },
        {
            "score": 0.04151030257344246,
            "start": 1591,
            "end": 1617,
            "answer": "A=A_7A_6A_5A_4A_3A_2A_1A_0"
        }
    ],
    [
        {
            "score": 0.06523824483156204,
            "start": 1,
            "end": 34,
            "answer": "The 2's Complement Representation"
        },
        {
            "score": 0.04551784321665764,
            "start": 1,
            "end": 54,
            "answer": "The 2's Complement Representation}  This set of notes"
        },
        {
            "score": 0.028627047315239906,
            "start": 5,
            "end": 34,
            "answer": "2's Complement Representation"
        },
        {
            "score": 0.028133513405919075,
            "start": 37,
            "end": 54,
            "answer": "This set of notes"
        },
        {
            "score": 0.02295800857245922,
            "start": 1,
            "end": 302,
            "answer": "The 2's Complement Representation}  This set of notes explains the rationale for using the 2's complement representation for signed integers and derives the representation  based on equivalence of the addition function to that of addition using the unsigned representation with the same number of bits"
        }
    ],
    [
        {
            "score": 0.22708435356616974,
            "start": 457,
            "end": 526,
            "answer": "we agree in advance on which pattern of bits represents which value}."
        },
        {
            "score": 0.12569527328014374,
            "start": 457,
            "end": 524,
            "answer": "we agree in advance on which pattern of bits represents which value"
        },
        {
            "score": 0.09516988694667816,
            "start": 455,
            "end": 526,
            "answer": "{ we agree in advance on which pattern of bits represents which value}."
        },
        {
            "score": 0.052678246051073074,
            "start": 455,
            "end": 524,
            "answer": "{ we agree in advance on which pattern of bits represents which value"
        },
        {
            "score": 0.028866179287433624,
            "start": 460,
            "end": 526,
            "answer": "agree in advance on which pattern of bits represents which value}."
        }
    ],
    [
        {
            "score": 0.3276560306549072,
            "start": 555,
            "end": 575,
            "answer": "beyond  your ability"
        },
        {
            "score": 0.1726876050233841,
            "start": 545,
            "end": 575,
            "answer": "currently beyond  your ability"
        },
        {
            "score": 0.09842759370803833,
            "start": 535,
            "end": 575,
            "answer": "probably) currently beyond  your ability"
        },
        {
            "score": 0.06422925740480423,
            "start": 534,
            "end": 575,
            "answer": "(probably) currently beyond  your ability"
        },
        {
            "score": 0.0535162091255188,
            "start": 435,
            "end": 575,
            "answer": "Reasoning about the relative merits of representations from a practical engineering perspective is (probably) currently beyond  your ability"
        }
    ],
    [
        {
            "score": 0.11057418584823608,
            "start": 3503,
            "end": 3505,
            "answer": "14"
        },
        {
            "score": 0.02703273296356201,
            "start": 3496,
            "end": 3505,
            "answer": "2  7 = 14"
        },
        {
            "score": 0.025491178035736084,
            "start": 3503,
            "end": 3526,
            "answer": "14, we have (A = 4)  10"
        },
        {
            "score": 0.010072107426822186,
            "start": 3292,
            "end": 3505,
            "answer": "1,083,102,112  7,323,127)  10, find A.  For this problem, we note that the first number is equivalent  to 2  10, while the second number is equivalent  to 7  10.  We then write (A = 2  7)  10, and, since 2  7 = 14"
        },
        {
            "score": 0.007951761595904827,
            "start": 3481,
            "end": 3505,
            "answer": "10, and, since 2  7 = 14"
        }
    ],
    [
        {
            "score": 0.2471119463443756,
            "start": 1619,
            "end": 1634,
            "answer": "we gain nothing"
        },
        {
            "score": 0.07631576061248779,
            "start": 1622,
            "end": 1634,
            "answer": "gain nothing"
        },
        {
            "score": 0.06563293188810349,
            "start": 1619,
            "end": 1786,
            "answer": "we gain nothing in that sense from either choice. If we choose to represent -8, however, notice that all patterns starting with a 1 bit then represent negative numbers"
        },
        {
            "score": 0.052149154245853424,
            "start": 1627,
            "end": 1634,
            "answer": "nothing"
        },
        {
            "score": 0.050644323229789734,
            "start": 1440,
            "end": 1786,
            "answer": "The number of arithmetic operations that overflow is the same with both choices (the choices are symmetric around 0, as are the combinations of input operands that  overflow), so we gain nothing in that sense from either choice. If we choose to represent -8, however, notice that all patterns starting with a 1 bit then represent negative numbers"
        }
    ],
    [
        {
            "score": 0.8652370572090149,
            "start": 1701,
            "end": 1712,
            "answer": "unambiguous"
        },
        {
            "score": 0.03126976266503334,
            "start": 1670,
            "end": 1712,
            "answer": "the meaning of each pattern is unambiguous"
        },
        {
            "score": 0.013957739807665348,
            "start": 1698,
            "end": 1712,
            "answer": "is unambiguous"
        },
        {
            "score": 0.00817370880395174,
            "start": 1685,
            "end": 1712,
            "answer": "each pattern is unambiguous"
        },
        {
            "score": 0.0025153174065053463,
            "start": 645,
            "end": 697,
            "answer": "we are left with all patterns beginning with a 1 bit"
        }
    ],
    [
        {
            "score": 0.24531890451908112,
            "start": 162,
            "end": 202,
            "answer": "gives  us an easy procedure for doing so"
        },
        {
            "score": 0.21917299926280975,
            "start": 172,
            "end": 202,
            "answer": "an easy procedure for doing so"
        },
        {
            "score": 0.10936001688241959,
            "start": 175,
            "end": 202,
            "answer": "easy procedure for doing so"
        },
        {
            "score": 0.05015017092227936,
            "start": 162,
            "end": 189,
            "answer": "gives  us an easy procedure"
        },
        {
            "score": 0.045729465782642365,
            "start": 64,
            "end": 202,
            "answer": "understanding negation of an integer represented using 2's complement fairly straightforward, and gives  us an easy procedure for doing so"
        }
    ],
    [
        {
            "score": 0.36902040243148804,
            "start": 1482,
            "end": 1503,
            "answer": "the { halting problem"
        },
        {
            "score": 0.35622045397758484,
            "start": 1488,
            "end": 1503,
            "answer": "halting problem"
        },
        {
            "score": 0.29721760749816895,
            "start": 1482,
            "end": 1503,
            "answer": "the { halting problem"
        },
        {
            "score": 0.2341674566268921,
            "start": 1488,
            "end": 1503,
            "answer": "halting problem"
        },
        {
            "score": 0.18406379222869873,
            "start": 1482,
            "end": 1505,
            "answer": "the { halting problem}."
        }
    ],
    [
        {
            "score": 0.029521018266677856,
            "start": 887,
            "end": 959,
            "answer": "his definition of computable was identical to the ``natural'' definition"
        },
        {
            "score": 0.01699887216091156,
            "start": 1042,
            "end": 1206,
            "answer": "a problem that cannot be solved by a Turing machine cannot be solved in any systematic manner, with any machine, or by any person.  This conjecture remains unproven"
        },
        {
            "score": 0.01645781844854355,
            "start": 891,
            "end": 959,
            "answer": "definition of computable was identical to the ``natural'' definition"
        },
        {
            "score": 0.01632310077548027,
            "start": 887,
            "end": 948,
            "answer": "his definition of computable was identical to the ``natural''"
        },
        {
            "score": 0.014537351205945015,
            "start": 882,
            "end": 959,
            "answer": "that his definition of computable was identical to the ``natural'' definition"
        }
    ],
    [
        {
            "score": 0.7857093214988708,
            "start": 1206,
            "end": 1220,
            "answer": "undecidability"
        },
        {
            "score": 0.7196533679962158,
            "start": 709,
            "end": 720,
            "answer": "undecidable"
        },
        {
            "score": 0.08460091799497604,
            "start": 504,
            "end": 720,
            "answer": "undecidable, using proof techniques almost identical to those developed for similar problems in the 1880s, is now known as { the halting problem}.    The halting problem is easy to state and easy to prove undecidable"
        },
        {
            "score": 0.07070230692625046,
            "start": 3504,
            "end": 3551,
            "answer": "no Turing machine can solve the halting problem"
        },
        {
            "score": 0.028278112411499023,
            "start": 1206,
            "end": 1657,
            "answer": "undecidability of the halting problem easier to understand if you first think about a related problem with which you may already be familiar, the Liar's paradox (which is at least 2,300 years old).  In its stengthened form, it is the following sentence: ``This sentence is not true.''   To see that no Turing machine can solve the halting problem, we begin by assuming that such a machine exists, and then show that its existence is self-contradictory"
        }
    ],
    [
        {
            "score": 0.24129122495651245,
            "start": 244,
            "end": 323,
            "answer": "to give you time to become familiar with the syntax and meaning of the language"
        },
        {
            "score": 0.12695299088954926,
            "start": 247,
            "end": 323,
            "answer": "give you time to become familiar with the syntax and meaning of the language"
        },
        {
            "score": 0.09784562140703201,
            "start": 244,
            "end": 356,
            "answer": "to give you time to become familiar with the syntax and meaning of the language, not to teach you how to program"
        },
        {
            "score": 0.051480505615472794,
            "start": 247,
            "end": 356,
            "answer": "give you time to become familiar with the syntax and meaning of the language, not to teach you how to program"
        },
        {
            "score": 0.028517726808786392,
            "start": 158,
            "end": 323,
            "answer": "Our purpose in showing you a high-level language at this early stage of the course is to give you time to become familiar with the syntax and meaning of the language"
        }
    ],
    [
        {
            "score": 0.16926124691963196,
            "start": 2455,
            "end": 2474,
            "answer": "slightly  confusing"
        },
        {
            "score": 0.16607405245304108,
            "start": 2465,
            "end": 2474,
            "answer": "confusing"
        },
        {
            "score": 0.09416282922029495,
            "start": 2455,
            "end": 2474,
            "answer": "slightly  confusing"
        },
        {
            "score": 0.06598443537950516,
            "start": 2330,
            "end": 2474,
            "answer": "Those with no programming experience may at first find the difference between variables in algebra and variables in programs slightly  confusing"
        },
        {
            "score": 0.04145176708698273,
            "start": 2330,
            "end": 2474,
            "answer": "Those with no programming experience may at first find the difference between variables in algebra and variables in programs slightly  confusing"
        }
    ],
    [
        {
            "score": 0.017636137083172798,
            "start": 4178,
            "end": 4182,
            "answer": "int}"
        },
        {
            "score": 0.014139567501842976,
            "start": 4176,
            "end": 4182,
            "answer": "{ int}"
        },
        {
            "score": 0.01362896990031004,
            "start": 3804,
            "end": 4182,
            "answer": "ECE 220.  The primitive data types in C include signed and unsigned integers of various sizes as well as single- and double-precision IEEE floating-point numbers.   The primitive integer types in C include both unsigned and 2's complement representations.  These types were originally defined so as to give reasonable performance when code was ported.  In particular, the { int}"
        },
        {
            "score": 0.01190499309450388,
            "start": 4178,
            "end": 4187,
            "answer": "int} type"
        },
        {
            "score": 0.009843559004366398,
            "start": 5182,
            "end": 5198,
            "answer": "int} and { long}"
        }
    ],
    [
        {
            "score": 0.20362639427185059,
            "start": 1145,
            "end": 1158,
            "answer": "unpredictable"
        },
        {
            "score": 0.20027130842208862,
            "start": 1132,
            "end": 1158,
            "answer": "its value is unpredictable"
        },
        {
            "score": 0.193531334400177,
            "start": 1132,
            "end": 1158,
            "answer": "its value is unpredictable"
        },
        {
            "score": 0.1740882694721222,
            "start": 1145,
            "end": 1158,
            "answer": "unpredictable"
        },
        {
            "score": 0.10321220010519028,
            "start": 1136,
            "end": 1158,
            "answer": "value is unpredictable"
        }
    ],
    [
        {
            "score": 0.1866128146648407,
            "start": 2662,
            "end": 2777,
            "answer": "copies the value of variable { B} into variable { A}, overwriting the bits representing the previous value of { A}."
        },
        {
            "score": 0.17661628127098083,
            "start": 304,
            "end": 326,
            "answer": "represent calculations"
        },
        {
            "score": 0.16958589851856232,
            "start": 304,
            "end": 380,
            "answer": "represent calculations such as arithmetic, comparisons, and logic operations"
        },
        {
            "score": 0.1341216266155243,
            "start": 2662,
            "end": 2715,
            "answer": "copies the value of variable { B} into variable { A},"
        },
        {
            "score": 0.05345964804291725,
            "start": 2716,
            "end": 2777,
            "answer": "overwriting the bits representing the previous value of { A}."
        }
    ],
    [
        {
            "score": 0.016319476068019867,
            "start": 5970,
            "end": 6034,
            "answer": "tries to convert input from the user into the appropriate result"
        },
        {
            "score": 0.008120269514620304,
            "start": 5979,
            "end": 6034,
            "answer": "convert input from the user into the appropriate result"
        },
        {
            "score": 0.007096652407199144,
            "start": 5970,
            "end": 6006,
            "answer": "tries to convert input from the user"
        },
        {
            "score": 0.0049760485999286175,
            "start": 3584,
            "end": 3618,
            "answer": "storing the results into variables"
        },
        {
            "score": 0.004708081483840942,
            "start": 5970,
            "end": 6110,
            "answer": "tries to convert input from the user into the appropriate result, then stores the result in memory at the address given by the next argument"
        }
    ],
    [
        {
            "score": 0.0018410031916573644,
            "start": 1343,
            "end": 1554,
            "answer": "analyzed by the front end of the compiler based on the specific programming language being used (in our case, the C language), then converted by the back end of the compiler into instructions for the desired ISA"
        },
        {
            "score": 0.001385452225804329,
            "start": 1343,
            "end": 1438,
            "answer": "analyzed by the front end of the compiler based on the specific programming language being used"
        },
        {
            "score": 0.0012210727436468005,
            "start": 1343,
            "end": 1368,
            "answer": "analyzed by the front end"
        },
        {
            "score": 0.0008874890045262873,
            "start": 1475,
            "end": 1554,
            "answer": "converted by the back end of the compiler into instructions for the desired ISA"
        },
        {
            "score": 0.0007818667800165713,
            "start": 1306,
            "end": 1554,
            "answer": "The preprocessed source code is then analyzed by the front end of the compiler based on the specific programming language being used (in our case, the C language), then converted by the back end of the compiler into instructions for the desired ISA"
        }
    ],
    [
        {
            "score": 0.14582470059394836,
            "start": 1,
            "end": 19,
            "answer": "The C Preprocessor"
        },
        {
            "score": 0.0656283050775528,
            "start": 1,
            "end": 21,
            "answer": "The C Preprocessor*}"
        },
        {
            "score": 0.03963400423526764,
            "start": 5,
            "end": 19,
            "answer": "C Preprocessor"
        },
        {
            "score": 0.02621145360171795,
            "start": 1,
            "end": 420,
            "answer": "The C Preprocessor*}  The C language uses a preprocessor to support inclusion of common information (stored in header files) into multiple source files.  The most frequent use of the preprocessor is to enable the unique definition of new data types and operations within header files that can then be included by reference within source files that make use of them.  This capability is based on the  { include directive"
        },
        {
            "score": 0.021860601380467415,
            "start": 0,
            "end": 19,
            "answer": "{The C Preprocessor"
        }
    ],
    [
        {
            "score": 0.9550525546073914,
            "start": 200,
            "end": 228,
            "answer": "binary arithmetic operations"
        },
        {
            "score": 0.364777535200119,
            "start": 2051,
            "end": 2062,
            "answer": "assignments"
        },
        {
            "score": 0.015213612467050552,
            "start": 2044,
            "end": 2062,
            "answer": "due to assignments"
        },
        {
            "score": 0.007836527191102505,
            "start": 2051,
            "end": 2063,
            "answer": "assignments."
        },
        {
            "score": 0.005485113710165024,
            "start": 136,
            "end": 228,
            "answer": "The most common form of { implicit type conversion} occurs with binary arithmetic operations"
        }
    ],
    [
        {
            "score": 0.2888791263103485,
            "start": 4493,
            "end": 4516,
            "answer": "intractable/undecidable"
        },
        {
            "score": 0.21492619812488556,
            "start": 4493,
            "end": 4516,
            "answer": "intractable/undecidable"
        },
        {
            "score": 0.06840474903583527,
            "start": 4335,
            "end": 4516,
            "answer": "undecidable ()  the halting problem ()  }   pre-Fall 2015 version   {Turing machines  {--}{{}{}  {}{}{}   universal computational device/ computing machine   intractable/undecidable"
        },
        {
            "score": 0.05720169469714165,
            "start": 4335,
            "end": 4516,
            "answer": "undecidable ()  the halting problem ()  }   pre-Fall 2015 version   {Turing machines  {--}{{}{}  {}{}{}   universal computational device/ computing machine   intractable/undecidable"
        },
        {
            "score": 0.03589613363146782,
            "start": 4493,
            "end": 4538,
            "answer": "intractable/undecidable   the halting problem"
        }
    ],
    [
        {
            "score": 0.010248158127069473,
            "start": 146,
            "end": 197,
            "answer": "prove that the conditions that we state are correct"
        },
        {
            "score": 0.009640106000006199,
            "start": 137,
            "end": 197,
            "answer": "formally prove that the conditions that we state are correct"
        },
        {
            "score": 0.006699950899928808,
            "start": 134,
            "end": 197,
            "answer": "we formally prove that the conditions that we state are correct"
        },
        {
            "score": 0.0047454615123569965,
            "start": 96,
            "end": 197,
            "answer": "complement addition.  For both types, we formally prove that the conditions that we state are correct"
        },
        {
            "score": 0.0036206692457199097,
            "start": 190,
            "end": 197,
            "answer": "correct"
        }
    ],
    [
        {
            "score": 0.007103175390511751,
            "start": 1757,
            "end": 1854,
            "answer": "The converse of an implication may or may not have the same truth value as the implication itself"
        },
        {
            "score": 0.005657176021486521,
            "start": 1808,
            "end": 1854,
            "answer": "the same truth value as the implication itself"
        },
        {
            "score": 0.005299105308949947,
            "start": 1757,
            "end": 1828,
            "answer": "The converse of an implication may or may not have the same truth value"
        },
        {
            "score": 0.004460345953702927,
            "start": 1788,
            "end": 1854,
            "answer": "may or may not have the same truth value as the implication itself"
        },
        {
            "score": 0.004220362287014723,
            "start": 1808,
            "end": 1828,
            "answer": "the same truth value"
        }
    ],
    [
        {
            "score": 0.4509863555431366,
            "start": 244,
            "end": 356,
            "answer": "if the number represented by the {N-bit} pattern produced for the sum does not actually represent the number A+B"
        },
        {
            "score": 0.21689070761203766,
            "start": 1056,
            "end": 1103,
            "answer": "if the carry out c_N of the addition is a 1 bit"
        },
        {
            "score": 0.16773177683353424,
            "start": 1044,
            "end": 1103,
            "answer": "if and only if the carry out c_N of the addition is a 1 bit"
        },
        {
            "score": 0.09491901099681854,
            "start": 247,
            "end": 356,
            "answer": "the number represented by the {N-bit} pattern produced for the sum does not actually represent the number A+B"
        },
        {
            "score": 0.037554070353507996,
            "start": 251,
            "end": 356,
            "answer": "number represented by the {N-bit} pattern produced for the sum does not actually represent the number A+B"
        }
    ],
    [
        {
            "score": 0.011060741730034351,
            "start": 4579,
            "end": 4663,
            "answer": "Given that an overflow has occurred, C must fall outside of the  representable range"
        },
        {
            "score": 0.008911008015275002,
            "start": 4616,
            "end": 4663,
            "answer": "C must fall outside of the  representable range"
        },
        {
            "score": 0.007291228976100683,
            "start": 4590,
            "end": 4663,
            "answer": "an overflow has occurred, C must fall outside of the  representable range"
        },
        {
            "score": 0.0063677080906927586,
            "start": 4329,
            "end": 4663,
            "answer": "similar, and leads to condition 2.  We again begin with inequalities for A and B:  {eqnarray*} 0  & A & < 2^{N-1} 0  & B & < 2^{N-1} {eqnarray*}  We add these two inequalities and replace A+B with C to obtain  {eqnarray*} 0  & C < & 2^N {eqnarray*}  Given that an overflow has occurred, C must fall outside of the  representable range"
        },
        {
            "score": 0.00615344662219286,
            "start": 1730,
            "end": 1760,
            "answer": "the addition does not overflow"
        }
    ]
]